{% extends "base_flask.html" %}

{% block title %}Implied Volatility Analysis{% endblock %}

{% block content %}
<div class="dashboard-container">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <h2>Navigation</h2>
        </div>
        <nav class="sidebar-nav">
            <ul>
                <li class="nav-item">
                    <a href="{{ url_for('index') }}" class="nav-link">
                        <i data-lucide="home"></i>
                        <span>Home</span>
                    </a>
                </li>
                                    <li class="nav-item">
                        <a href="{{ url_for('cv_mathis_le_gall') }}" class="nav-link">
                            <i data-lucide="user"></i>
                            <span>Mathis Le Gall CV</span>
                        </a>
                    </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link dropdown-toggle" onclick="toggleDropdown(event)">
                        <i data-lucide="trending-up"></i>
                        <span>Market Overview</span>
                        <i data-lucide="chevron-down" class="dropdown-arrow"></i>
                    </a>
                    <ul class="dropdown-menu">
                        <li class="dropdown-item">
                            <a href="{{ url_for('indices_actions') }}" class="nav-link">
                                <i data-lucide="candlestick-chart"></i>
                                <span>Indices & Stocks</span>
                            </a>
                        </li>
                        <li class="dropdown-item">
                            <a href="{{ url_for('crypto') }}" class="nav-link">
                                <i data-lucide="bar-chart"></i>
                                <span>Cryptocurrencies</span>
                            </a>
                        </li>
                        <li class="dropdown-item">
                            <a href="{{ url_for('rates_fx') }}" class="nav-link">
                                <i data-lucide="trending-up"></i>
                                <span>Rates & FX</span>
                            </a>
                        </li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('analyse_actions_indices') }}" class="nav-link">
                        <i data-lucide="activity"></i>
                        <span>Market Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('call_put') }}" class="nav-link">
                        <i data-lucide="line-chart"></i>
                        <span>Call & Put</span>
                    </a>
                </li>

                <li class="nav-item">
                    <a href="{{ url_for('volatility_surface') }}" class="nav-link active">
                        <i data-lucide="thermometer"></i>
                        <span>Implied Volatility Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('analyse_volatility') }}" class="nav-link">
                        <i data-lucide="twitter"></i>
                        <span>Tweet Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('description_app') }}" class="nav-link">
                        <i data-lucide="info"></i>
                        <span>App Description</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <header class="content-header">
            <div class="main-header-flex">
                <div class="main-header-left">
                </div>
                <div class="main-header-center">
                    <!-- Space to balance the layout -->
                </div>
                <div class="main-header-right">
                    <h1 class="header-title">Implied Volatility Analysis</h1>
                </div>
            </div>
        </header>

        <!-- Content -->
        <div class="content-area">
            <div class="main-content-area">
            <div class="page-header">
                <div class="header-content">
                    <div class="header-left">
                        <h1 class="page-title">
                            <i data-lucide="thermometer" class="title-icon"></i>
                            Implied Volatility Analysis
                        </h1>
                        <p class="page-subtitle">
                            Interactive analysis of implied volatility based on real market options data
                        </p>
                        
                        <!-- Tradier API Information -->
                        <div class="api-warning-card">
                            <div class="warning-content">
                                <div class="warning-title">
                                    📊 Tradier API - Real-time Data
                                </div>
                                <div class="warning-text">
                                    This surface uses the Tradier API for real-time options data. Data is calculated using Black-Scholes model for implied volatility. Loading times are typically under 10 seconds.
                                </div>
                            </div>
                        </div>
                        
                        <!-- Progress Bar Card -->
                        <div id="progress-card" class="progress-card" style="display: block;">
                            <div class="progress-content">
                                <div class="progress-header">
                                    <div class="progress-indicator">
                                        <div class="progress-dot"></div>
                                        <span class="progress-text">Loading Tickers...</span>
                                    </div>
                                </div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar">
                                        <div id="progress-fill" class="progress-fill"></div>
                                    </div>
                                    <div class="progress-percentage">
                                        <span id="progress-text">0%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- API Status Indicator -->
                    <div id="api-status" class="api-status-card">
                        <div class="status-indicator">
                            <div id="api-status-indicator" class="status-dot"></div>
                            <span id="api-status-text" class="status-text">Checking API...</span>
                        </div>
                        <div class="status-details">
                            <div class="api-name">Options API</div>
                            <div id="api-response-time" class="response-time">--</div>
                        </div>
                        <div class="status-meta">
                            <i data-lucide="database" class="meta-icon"></i>
                            <span class="meta-text">Options Data</span>
                        </div>
                    </div>
                </div>
            </div>

            <main class="main-content-area">
                <!-- Section 1: Volatility Smile Analysis -->
                <section class="analysis-section volatility-smile-section">

                    <!-- Separate control block for Smiles - ABOVE -->
                    <div class="volatility-smile-container">
                        <!-- Header Section -->
                        <div class="smile-header">
                            <div class="header-content">
                                <div class="header-title">
                                    <i data-lucide="trending-up" class="header-icon"></i>
                                    <h1 class="main-section-title">Volatility Smile Analysis</h1>
                                </div>
                                <div class="header-subtitle">
                                    <h2 class="sub-section-title">Compare implied volatility smiles across multiple tickers and maturities</h2>
                                </div>
                            </div>
                            <div class="data-source-badge">
                                <i data-lucide="database" class="badge-icon"></i>
                                <span>Powered by Tradier API</span>
                            </div>
                        </div>

                        <!-- Control Panel -->
                        <div class="control-panel">
                            <div class="control-section">
                                <div class="section-header">
                                    <i data-lucide="plus-circle" class="section-icon"></i>
                                    <h3>Add Tickers</h3>
                                </div>
                                <div class="ticker-input-group">
                                    <select id="smile-ticker-select" class="modern-select" disabled>
                                        <option value="">Chargement des tickers...</option>
                                        <option value="AAPL">AAPL - Apple Inc.</option>
                                        <option value="MSFT">MSFT - Microsoft Corp.</option>
                                        <option value="GOOGL">GOOGL - Alphabet Inc.</option>
                                        <option value="AMZN">AMZN - Amazon.com Inc.</option>
                                        <option value="TSLA">TSLA - Tesla Inc.</option>
                                        <option value="META">META - Meta Platforms Inc.</option>
                                        <option value="NVDA">NVDA - NVIDIA Corp.</option>
                                        <option value="SPY">SPY - SPDR S&P 500 ETF</option>
                                        <option value="QQQ">QQQ - Invesco QQQ Trust</option>
                                        <option value="IWM">IWM - iShares Russell 2000 ETF</option>
                                        <option value="NFLX">NFLX - Netflix Inc.</option>
                                        <option value="AMD">AMD - Advanced Micro Devices</option>
                                        <option value="INTC">INTC - Intel Corp.</option>
                                        <option value="CRM">CRM - Salesforce Inc.</option>
                                    </select>
                                </div>
                            </div>

                            <div class="control-section">
                                <div class="section-header">
                                    <i data-lucide="check-circle" class="section-icon"></i>
                                    <h3>Selected Tickers</h3>
                                    <span id="smile-ticker-count" class="count-badge">0</span>
                                </div>
                                <div id="smile-selected-tickers" class="tickers-container">
                                    <div class="empty-tickers">
                                        <i data-lucide="building-2" class="empty-icon"></i>
                                        <span>No tickers selected yet</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Combinations Table -->
                        <div class="combinations-section">
                            <div class="section-header">
                                <i data-lucide="layers" class="section-icon"></i>
                                <h3>Selected Combinations</h3>
                                <span id="combination-count" class="count-badge">0</span>
                            </div>
                            
                            <div class="combinations-table-container">
                                <table class="combinations-table">
                        <thead>
                            <tr>
                                <th>Ticker</th>
                                <th>Available Maturities</th>
                                <th>Selected Combinations</th>
                            </tr>
                        </thead>
                                    <tbody>
                                        <!-- Le contenu sera généré dynamiquement par JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="action-buttons">
                            <button id="smile-compare-btn" class="primary-button" disabled>
                                <i data-lucide="bar-chart-3" class="button-icon"></i>
                                <span>Generate Volatility Smiles</span>
                            </button>
                            <button id="clear-all-btn" class="secondary-button" disabled>
                                <i data-lucide="trash-2" class="button-icon"></i>
                                <span>Clear All</span>
                            </button>
                        </div>
                    </div>

                    <!-- Smile of Volatility Section -->
                    <div class="smile-chart-main-container">
                        <!-- En-tête avec titre et contrôles -->
                        <div class="smile-chart-header">
                            <div class="smile-chart-title-section">
                                <div class="smile-chart-title" id="smile-chart-title">
                                    <i data-lucide="trending-up" class="smile-chart-icon"></i>
                                    <h2 class="chart-main-title">Comparison of Volatility Smiles</h2>
                                </div>
                                <p class="smile-chart-subtitle" id="smile-chart-subtitle"><h3 class="chart-sub-title">Compare implied volatility smiles between different stocks for a specific maturity</h3></p>
                            </div>
                            <div class="smile-chart-controls">
                                <button id="legend-toggle-btn" class="legend-toggle-btn" title="Toggle Legend">
                                    <i data-lucide="eye" class="legend-toggle-icon"></i>
                                    <span class="legend-toggle-text">Legend</span>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Graphique avec bordure pointillée -->
                        <div class="smile-chart-dotted-container">
                            <div id="smile-chart" class="smile-chart-plot">
                                <div id="smile-chart-placeholder" class="chart-placeholder">
                                    <div class="placeholder-content">
                                        <div class="placeholder-icon">
                                            <i data-lucide="bar-chart" style="width: 48px; height: 48px; color: #6b7280;"></i>
                                        </div>
                                        <h4>Comparison of Smiles</h4>
                                        <p>Add tickers and click "Generate Volatility Smiles" to display the implied volatility curves</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Smile Comparison Statistics -->
                        <div id="smile-statistics" class="chart-container statistics-container hidden">
                            <div class="chart-header">
                                <div class="chart-title">
                                    Comparison Statistics
                                </div>
                            </div>
                            
                            <div id="smile-comparison-stats" class="comparison-stats">
                                <!-- Les statistiques seront générées dynamiquement -->
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Section 2: Term Structure Comparison -->
                <section class="analysis-section volatility-smile-section term-structure-section">

                    <!-- Separate control block for Term Structure - ABOVE -->
                    <div class="volatility-smile-container">
                        <!-- Header Section -->
                        <div class="smile-header">
                            <div class="header-content">
                                <div class="header-title">
                                    <i data-lucide="trending-up" class="header-icon"></i>
                                    <h1 class="main-section-title">Term Structure Comparison</h1>
                                </div>
                                <div class="header-subtitle">
                                    <h2 class="sub-section-title">Compare term structure across multiple tickers and maturities</h2>
                                </div>
                            </div>
                            <div class="data-source-badge">
                                <i data-lucide="database" class="badge-icon"></i>
                                <span>Powered by Tradier API</span>
                            </div>
                        </div>

                        <!-- Control Panel -->
                        <div class="control-panel">
                            <div class="control-section">
                                <div class="section-header">
                                    <i data-lucide="plus-circle" class="section-icon"></i>
                                    <h3>Add Tickers</h3>
                                </div>
                                <div class="ticker-input-group">
                                    <select id="term-structure-ticker-select" class="modern-select" disabled>
                                        <option value="">Chargement des tickers...</option>
                                        <option value="AAPL">AAPL - Apple Inc.</option>
                                        <option value="MSFT">MSFT - Microsoft Corp.</option>
                                        <option value="GOOGL">GOOGL - Alphabet Inc.</option>
                                        <option value="AMZN">AMZN - Amazon.com Inc.</option>
                                        <option value="TSLA">TSLA - Tesla Inc.</option>
                                        <option value="META">META - Meta Platforms Inc.</option>
                                        <option value="NVDA">NVDA - NVIDIA Corp.</option>
                                        <option value="SPY">SPY - SPDR S&P 500 ETF</option>
                                        <option value="QQQ">QQQ - Invesco QQQ Trust</option>
                                        <option value="IWM">IWM - iShares Russell 2000 ETF</option>
                                        <option value="NFLX">NFLX - Netflix Inc.</option>
                                        <option value="AMD">AMD - Advanced Micro Devices</option>
                                        <option value="INTC">INTC - Intel Corp.</option>
                                        <option value="CRM">CRM - Salesforce Inc.</option>
                                    </select>
                                </div>
                            </div>

                            <div class="control-section">
                                <div class="section-header">
                                    <i data-lucide="check-circle" class="section-icon"></i>
                                    <h3>Selected Tickers</h3>
                                    <span id="term-structure-ticker-count" class="count-badge">0</span>
                                </div>
                                <div id="term-structure-selected-tickers" class="tickers-container">
                                    <div class="empty-tickers">
                                        <i data-lucide="building-2" class="empty-icon"></i>
                                        <span>No tickers selected yet</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Combinations Table -->
                        <div class="combinations-section">
                            <div class="section-header">
                                <i data-lucide="layers" class="section-icon"></i>
                                <h3>Selected Combinations</h3>
                                <span id="term-structure-combination-count" class="count-badge">0</span>
                            </div>
                            
                            <div class="combinations-table-container">
                                <table class="combinations-table">
                        <thead>
                            <tr>
                                <th>Ticker</th>
                                <th>Available Strike Maturity</th>
                                <th>Selected Combinations</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Le contenu sera généré dynamiquement par JavaScript -->
                        </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="action-buttons">
                            <button id="term-structure-compare-btn" class="primary-button" disabled>
                                <i data-lucide="bar-chart-3" class="button-icon"></i>
                                <span>Generate Term Structure</span>
                            </button>
                            <button id="term-structure-clear-all-btn" class="secondary-button" disabled>
                                <i data-lucide="trash-2" class="button-icon"></i>
                                <span>Clear All</span>
                            </button>
                        </div>
                    </div>

                    <!-- Term Structure of Volatility Section -->
                    <div class="smile-chart-main-container">
                        <!-- En-tête avec titre et contrôles -->
                        <div class="smile-chart-header">
                            <div class="smile-chart-title-section">
                                <div class="smile-chart-title" id="term-structure-chart-title">
                                    <i data-lucide="trending-up" class="smile-chart-icon"></i>
                                    <h2 class="chart-main-title">Comparison of Term Structure</h2>
                                </div>
                                <p class="smile-chart-subtitle" id="term-structure-chart-subtitle"><h3 class="chart-sub-title">Compare term structure between different stocks</h3></p>
                            </div>
                            <div class="smile-chart-controls">
                                <button id="term-structure-legend-toggle-btn" class="legend-toggle-btn" title="Toggle Legend">
                                    <i data-lucide="eye" class="legend-toggle-icon"></i>
                                    <span class="legend-toggle-text">Legend</span>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Graphique avec bordure pointillée -->
                        <div class="smile-chart-dotted-container">
                            <div id="term-structure-chart" class="smile-chart-plot">
                                <div id="term-structure-chart-placeholder" class="chart-placeholder">
                                    <div class="placeholder-content">
                                        <div class="placeholder-icon">
                                            <i data-lucide="bar-chart" style="width: 48px; height: 48px; color: #6b7280;"></i>
                                        </div>
                                        <h4>Comparison of Term Structure</h4>
                                        <p>Add tickers and click "Generate Term Structure" to display the term structure curves</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Term Structure Comparison Statistics -->
                        <div id="term-structure-statistics" class="chart-container statistics-container hidden">
                            <div class="chart-header">
                                <div class="chart-title">
                                    Comparison Statistics
                                </div>
                            </div>
                            
                            <div id="term-structure-comparison-stats" class="comparison-stats">
                                <!-- Les statistiques seront générées dynamiquement -->
                            </div>
                        </div>
                    </div>
                </section>


                <!-- Section 3: 3D Volatility Surface Analysis -->
                <section class="analysis-section volatility-3d-section">
                    <div class="section-header">
                        <div class="section-title">
                            <i data-lucide="layers" class="section-icon"></i>
                            <h1 class="main-section-title">3D Volatility Surface Analysis</h1>
                        </div>
                        <div class="section-subtitle">
                            <h2 class="sub-section-title">Interactive 3D visualization of implied volatility</h2>
                        </div>
                    </div>

                    <!-- Configuration Section for 3D Surface -->
                    <div class="options-form-container">
                        <div class="options-form">
                            <!-- Main Parameters -->
                            <div class="form-section">
                                <div class="form-grid">
                                    <div class="form-field">
                                        <label for="vs-symbol-select" class="field-label">
                                            <i data-lucide="building-2" class="field-icon"></i>
                                            Symbol
                                        </label>
                                        <div class="symbol-select-container">
                                            <select id="vs-symbol-select" class="form-input" disabled>
                                                <option value="">Chargement des tickers...</option>
                                            </select>
                                        </div>
                                        <div id="vs-custom-wrap" class="hidden">
                                            <input type="text" id="vs-symbol" class="form-input" placeholder="Enter a symbol (ex: AAPL)">
                                        </div>
                                    </div>
                                    
                                    <div class="form-field">
                                        <label for="vs-provider" class="field-label">
                                            <i data-lucide="database" class="field-icon"></i>
                                            Data Provider
                                        </label>
                                        <select id="vs-provider" class="form-input">
                                            <option value="tradier">Tradier API</option>
                                        </select>
                                    </div>
                                    

                                    
                                    <div class="form-field">
                                        <label for="vs-span" class="field-label">
                                            <i data-lucide="target" class="field-icon"></i>
                                            Spot Range
                                        </label>
                                        <select id="vs-span" class="form-input">
                                            <option value="0.1">10%</option>
                                            <option value="0.2">20%</option>
                                            <option value="0.3">30%</option>
                                            <option value="0.5" selected>50%</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                                                         <div class="form-actions">
                                 <button id="vs-load" class="calculate-btn">
                                     <i data-lucide="play" class="btn-icon"></i>
                                     Load Surface
                                 </button>
                             </div>
                        </div>
                    </div>

                    <!-- Parameters Display -->
                    <div id="vs-parameters" class="options-form-container hidden">
                        <div class="form-header">
                            <h3 class="form-title">
                                <i data-lucide="bar-chart" class="form-icon"></i>
                                Calculation Parameters
                            </h3>
                            <p class="form-subtitle">Detailed information about implied volatility analysis</p>
                        </div>
                        
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="dollar-sign" class="metric-icon"></i>
                                    <div class="metric-label">Spot Price</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-spot-price">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="database" class="metric-icon"></i>
                                    <div class="metric-label">Source</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-data-source">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="calendar" class="metric-icon"></i>
                                    <div class="metric-label">Maturities</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-maturities-count">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="target" class="metric-icon"></i>
                                    <div class="metric-label">Strikes</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-strikes-count">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="trending-up" class="metric-icon"></i>
                                    <div class="metric-label">Risk-Free Rate</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number">5.00%</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="percent" class="metric-icon"></i>
                                    <div class="metric-label">Dividend Yield</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number">0.00%</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="arrow-down" class="metric-icon"></i>
                                    <div class="metric-label">IV Minimum</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-iv-min">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="arrow-up" class="metric-icon"></i>
                                    <div class="metric-label">IV Maximum</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-iv-max">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="metric-card">
                                <div class="metric-header">
                                    <i data-lucide="bar-chart-2" class="metric-icon"></i>
                                    <div class="metric-label">IV Average</div>
                                </div>
                                <div class="metric-values">
                                    <div class="metric-value">
                                        <span class="value-number" id="vs-iv-avg">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                                         <!-- Debug JSON Section -->
                     <div id="debug-json-section" class="options-form-container hidden">
                         <div class="form-header">
                             <h3 class="form-title">
                                 Data
                             </h3>
                         </div>
                         
                         <div class="debug-content">
                             <div class="debug-tabs">
                                 <button class="debug-tab active" data-tab="summary">Summary</button>
                                 <button class="debug-tab" data-tab="options">Detailed Options</button>
                                <button class="debug-tab" data-tab="iv-matrix">IV Matrix</button>
                                <button class="debug-tab" data-tab="iv-details">IV Details</button>
                                <button class="debug-tab" data-tab="raw">Raw JSON</button>
                             </div>
                             
                             <div class="debug-panels">
                                 <div id="summary-panel" class="debug-panel active">
                                     <div class="summary-grid">
                                         <div class="summary-item">
                                             <span class="summary-label">Symbol</span>
                                             <span class="summary-value" id="debug-symbol">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Spot Price</span>
                                             <span class="summary-value" id="debug-spot-price">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Source</span>
                                             <span class="summary-value" id="debug-source">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Total Options</span>
                                             <span class="summary-value" id="debug-total-options">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Calls</span>
                                             <span class="summary-value" id="debug-calls-count">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Puts</span>
                                             <span class="summary-value" id="debug-puts-count">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Maturities</span>
                                             <span class="summary-value" id="debug-maturities-count">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">Strikes</span>
                                             <span class="summary-value" id="debug-strikes-count">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">IV Min</span>
                                             <span class="summary-value" id="debug-iv-min">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">IV Max</span>
                                             <span class="summary-value" id="debug-iv-max">-</span>
                                         </div>
                                         <div class="summary-item">
                                             <span class="summary-label">IV Average</span>
                                             <span class="summary-value" id="debug-iv-avg">-</span>
                                         </div>

                                     </div>
                                 </div>
                                 
                                <div id="iv-details-panel" class="debug-panel">
                                    <div class="iv-details-container">
                                        <h4>Implied Volatility Details</h4>
                                        <div class="iv-details-info">
                                            <p>Detailed view of all options with their implied volatilities</p>
                                        </div>
                                        <div class="iv-details-table-container">
                                            <table id="iv-details-table" class="iv-details-table">
                                                <thead>
                                                    <tr>
                                                        <th>Maturity</th>
                                                        <th>Strike</th>
                                                        <th>Type</th>
                                                        <th>Price</th>
                                                        <th>IV</th>
                                                        <th>IV %</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="iv-details-tbody">
                                                    <!-- Les données seront ajoutées dynamiquement -->
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                                
                                <div id="raw-panel" class="debug-panel">
                                    <div class="json-viewer">
                                        <pre id="debug-raw-json" class="json-content"></pre>
                                    </div>
                                </div>
                                 
                                 <div id="options-panel" class="debug-panel">
                                     <div class="options-table-container">
                                         <table id="debug-options-table" class="options-table">
                                             <thead>
                                                 <tr>
                                                     <th>Contract</th>
                                                     <th>Type</th>
                                                     <th>Strike</th>
                                                     <th>Price</th>
                                                     <th>IV (%)</th>
                                                     <th>Expiration</th>
                                                 </tr>
                                             </thead>
                                             <tbody id="debug-options-tbody">
                                             </tbody>
                                         </table>
                                     </div>
                                 </div>
                                 
                                 <div id="iv-matrix-panel" class="debug-panel">
                                     <div class="iv-matrix-container">
                                         <h4>Implied Volatility Matrix</h4>
                                         <div class="matrix-info">
                                             <p>Lines: Maturities (years) | Columns: Strikes ($)</p>
                                         </div>
                                         <div id="debug-iv-matrix" class="iv-matrix"></div>
                                     </div>
                                 </div>
                             </div>
                         </div>
                     </div>

                     <!-- 3D Surface Chart -->
                     <div class="volatility-3d-chart-container">
                         <div class="volatility-3d-chart-header">
                             <div>
                                 <div class="volatility-3d-chart-title">
                                     <i data-lucide="layers" class="volatility-3d-chart-icon"></i>
                                     Implied Volatility 3D Surface
                                 </div>
                                 <p class="volatility-3d-chart-subtitle">Interactive visualization of implied volatility in three dimensions with Tradier data</p>
                             </div>

                         </div>
                         
                         <div id="vs-plot" class="volatility-3d-plot-container">
                             <div id="vs-plot-placeholder" class="volatility-3d-placeholder">
                                 <div class="volatility-3d-placeholder-icon">
                            <i data-lucide="bar-chart" style="width: 48px; height: 48px; color: #6b7280;"></i>
                        </div>
                                 <div class="volatility-3d-placeholder-title">Ready to analyze</div>
                                 <div class="volatility-3d-placeholder-text">Select a symbol and click "Load Surface" to display the 3D interactive visualization</div>
                             </div>
                         </div>
                         
                         <!-- Container for statistics - SUPPRIMÉ selon demande utilisateur -->
                         <!-- Les statistiques sont maintenant affichées dans la section Debug -->
                     </div>
                </section>
            </main>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script>
    // Attendre que le DOM soit chargé avant d'exécuter le code
    document.addEventListener('DOMContentLoaded', function() {
        // Gestion du menu mobile
        const mobileMenuBtn = document.getElementById('mobile-menu-btn');
        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => {
                document.querySelector('.sidebar').classList.toggle('open');
            });
        }
        
        // Fermer le menu en cliquant en dehors
        document.addEventListener('click', (e) => {
            const sidebar = document.querySelector('.sidebar');
            const mobileBtn = document.getElementById('mobile-menu-btn');
            
            if (sidebar && mobileBtn && !sidebar.contains(e.target) && !mobileBtn.contains(e.target)) {
                sidebar.classList.remove('open');
            }
        });
    
    // Fonction pour mettre à jour le statut de l'API
    function updateApiStatus(status, responseTime = null) {
        const indicator = document.getElementById('api-status-indicator');
        const statusText = document.getElementById('api-status-text');
        const responseTimeEl = document.getElementById('api-response-time');
        
        indicator.classList.remove('connected', 'error', 'checking');
        
        switch(status) {
            case 'connected':
                indicator.classList.add('connected');
                statusText.textContent = 'API Connected';
                if (responseTime) {
                    responseTimeEl.textContent = `${responseTime}ms`;
                }
                break;
            case 'error':
                indicator.classList.add('error');
                statusText.textContent = 'API Offline';
                responseTimeEl.textContent = 'Error';
                break;
            case 'checking':
                indicator.classList.add('checking');
                statusText.textContent = 'Checking API...';
                responseTimeEl.textContent = '--';
                break;
        }
    }
    
    // Vérification initiale du statut API
    async function checkApiStatus() {
        try {
            updateApiStatus('checking');
            const startTime = performance.now();
            const response = await fetch('/api/vol-surface-3d-tradier-simple/SPY?span=0.3');
            const data = await response.json();
            const endTime = performance.now();
            const responseTime = Math.round(endTime - startTime);
            
            if (data.error) {
                // Si SPY ne fonctionne pas, essayer QQQ
                const response2 = await fetch('/api/vol-surface-3d-tradier-simple/QQQ?span=0.3');
                const data2 = await response2.json();
                
                if (data2.error) {
                    throw new Error('API disponible mais données limitées');
                }
                
                updateApiStatus('connected', responseTime);
            } else {
                updateApiStatus('connected', responseTime);
            }
        } catch (error) {
            console.error('Erreur de vérification API:', error);
            updateApiStatus('error');
        }
    }
    
    // Vérification API supprimée - plus d'appels automatiques
    // checkApiStatus(); // Désactivé pour éviter les appels automatiques
    
    // Charger les symboles disponibles depuis l'API (pour la volatilité 3D)
    async function loadAvailableSymbols() {
        // Utiliser la fonction globale unifiée
        await loadGlobalAvailableTickers();
        
        // Mettre à jour le select de la volatilité 3D
        updateVolatility3DSymbolSelect();
    }
    
    // Mettre à jour le select de symboles pour la volatilité 3D (utilise les données globales)
    function updateVolatility3DSymbolSelect() {
        const selectSymbol = document.getElementById('vs-symbol-select');
        
        if (!selectSymbol) {
            console.warn('⚠️ Select vs-symbol-select non trouvé');
            return;
        }
        
        // Vider les listes existantes
        selectSymbol.innerHTML = '';
        
        // Utiliser les données globales unifiées
        if (globalAvailableTickers && globalAvailableTickers.length > 0) {
            globalAvailableTickers.forEach(ticker => {
                const option = document.createElement('option');
                option.value = ticker.symbol;
                option.textContent = ticker.label;
                // Préserver les données APIs si disponibles
                if (ticker.apis) {
                    option.dataset.apis = JSON.stringify(ticker.apis);
                }
                selectSymbol.appendChild(option);
            });
            
            // Ajouter l'option personnalisée
            const customOption = document.createElement('option');
            customOption.value = '__custom__';
            customOption.textContent = 'Custom...';
            selectSymbol.appendChild(customOption);
            
            // Définir le premier ticker comme valeur par défaut
            selectSymbol.value = globalAvailableTickers[0].symbol;
            
            // Activer tous les selects et masquer les spinners
            const allTickerSelects = [
                'vs-symbol-select',
                'smile-ticker-select', 
                'term-structure-ticker-select'
            ];
            
            allTickerSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.disabled = false;
                    // Recharger les options pour les autres selects
                    if (selectId !== 'vs-symbol-select') {
                        updateTickerDropdown();
                        updateTermStructureTickerDropdown();
                    }
                }
            });
            
            
            
            // La barre de progression sera masquée par completeProgressBar()
            
            console.log(`✅ ${globalAvailableTickers.length} symboles mis à jour pour la volatilité 3D (source unifiée)`);
        } else {
            console.warn('⚠️ Aucun ticker global disponible pour la volatilité 3D');
            // En cas d'erreur, garder le select désactivé
            selectSymbol.disabled = true;
            selectSymbol.innerHTML = '<option value="">Erreur de chargement des tickers</option>';
        }
        }
    
    // Fonction legacy pour compatibilité (utilise maintenant la fonction unifiée)
    function updateSymbolSelects(symbolsData) {
        // Rediriger vers la nouvelle fonction unifiée
        updateVolatility3DSymbolSelect();
    }
    
    // Adapter les options de provider selon le symbole sélectionné
    function updateProviderOptions(selectedSymbol) {
        const providerSelect = document.getElementById('vs-provider');
        const rawProviderSelect = document.getElementById('raw-provider');
        
        // Utiliser les données globales au lieu de window.availableSymbols
        if (!globalAvailableTickers || globalAvailableTickers.length === 0) return;
        
        // Toujours garder les deux APIs disponibles
        const availableApis = ['tradier'];
        
        // Mettre à jour les options de provider
        [providerSelect, rawProviderSelect].forEach(select => {
            if (!select) return;
            
            // Sauvegarder la valeur actuelle
            const currentValue = select.value;
            
            // Vider et recréer les options
            select.innerHTML = '';
            
            
            if (availableApis.includes('tradier')) {
                const option = document.createElement('option');
                option.value = 'tradier';
                option.textContent = 'Tradier API';
                select.appendChild(option);
            }
            
            // Restaurer la valeur si elle est toujours disponible
            if (availableApis.includes(currentValue)) {
                select.value = currentValue;
            } else if (availableApis.length > 0) {
                select.value = availableApis[0];
            }
        });
        
    }
    
    // Chargement automatique des symboles supprimé - plus d'appels automatiques
    // loadAvailableSymbols(); // Désactivé pour éviter les appels automatiques
    
    // Fonction pour charger les symboles Tradier
    async function loadTradierSymbols() {
        const progressCard = document.getElementById('progress-card');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        
        // Désactiver tous les selects de tickers
        const allTickerSelects = [
            'vs-symbol-select',
            'smile-ticker-select', 
            'term-structure-ticker-select'
        ];
        
        allTickerSelects.forEach(selectId => {
            const select = document.getElementById(selectId);
            if (select) {
                select.disabled = true;
                select.innerHTML = '<option value="">Chargement des tickers...</option>';
            }
        });
        
        
        // La barre de progression est déjà démarrée et visible
        
        try {
            // Utiliser la fonction globale unifiée au lieu d'un appel API séparé
            await loadGlobalAvailableTickers();
            
            // Finaliser la progression
            completeProgressBar();
            
            updateVolatility3DSymbolSelect();
        } catch (error) {
            console.error('Erreur lors du chargement des tickers:', error);
            // En cas d'erreur, afficher un message d'erreur
            if (selectSymbol) {
                selectSymbol.innerHTML = '<option value="">Erreur de chargement des tickers</option>';
                selectSymbol.disabled = true;
            }
            
            
            // Masquer la barre de progression en cas d'erreur
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            const progressCard = document.getElementById('progress-card');
            if (progressCard) {
                progressCard.style.display = 'none';
            }
        }
    }
    
    // Variables globales pour la barre de progression
    let progressInterval = null;
    let currentProgress = 0;
    
    // Fonction pour démarrer la barre de progression
    function startProgressBar() {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        
        if (!progressFill || !progressText) return;
        
        // Réinitialiser la progression
        currentProgress = 0;
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
    }
    
    // Fonction pour mettre à jour la barre de progression
    function updateProgressBar(progress) {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        
        if (!progressFill || !progressText) return;
        
        currentProgress = Math.min(progress, 100);
        progressFill.style.width = currentProgress + '%';
        progressText.textContent = Math.round(currentProgress) + '%';
    }
    
    // Fonction pour finaliser la barre de progression
    function completeProgressBar() {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        
        if (!progressFill || !progressText) return;
        
        // Arrêter l'intervalle
        if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
        
        // Finaliser à 100%
        currentProgress = 100;
        progressFill.style.width = '100%';
        progressText.textContent = '100%';
        
        // Masquer la barre après un court délai
        setTimeout(() => {
            const progressCard = document.getElementById('progress-card');
            if (progressCard) {
                progressCard.style.display = 'none';
            }
        }, 500);
    }
    
    // Fonction pour mettre à jour le select avec les symboles Tradier (utilise maintenant la fonction unifiée)
    function updateSymbolSelectWithTradier(symbols) {
        // Rediriger vers la fonction unifiée
        updateVolatility3DSymbolSelect();
    }
    
    // Gestion du changement de provider
    const providerSelect = document.getElementById('vs-provider');
    if (providerSelect) {
        providerSelect.addEventListener('change', function() {
            const provider = this.value;
            
            if (provider === 'tradier') {
                // Charger les symboles Tradier
                loadTradierSymbols();
            } else {
                // Recharger les symboles par défaut
                loadAvailableSymbols();
            }
        });
    }
    
    // Gestion des symboles personnalisés
    const selectSymbol = document.getElementById('vs-symbol-select');
    const customWrap = document.getElementById('vs-custom-wrap');
    const customInput = document.getElementById('vs-symbol');
    
    function getCurrentSymbol() {
        return (selectSymbol && selectSymbol.value === '__custom__') ? (customInput && customInput.value || '').trim() : (selectSymbol ? selectSymbol.value : '');
    }
    
    if (selectSymbol) {
        selectSymbol.addEventListener('change', async () => {
            const show = selectSymbol.value === '__custom__';
            if (show) {
                if (customWrap) customWrap.classList.remove('hidden');
                if (customInput) customInput.focus();
            } else {
                if (customWrap) customWrap.classList.add('hidden');
                // Mettre à jour les options de provider selon le symbole sélectionné
                updateProviderOptions(selectSymbol.value);
                
                // Valider le ticker sélectionné pour la volatilité 3D
                const selectedTicker = selectSymbol.value;
                if (selectedTicker && selectedTicker !== '__custom__') {
                    const hasOptions = await validateTickerHasOptions(selectedTicker);
                    if (!hasOptions) {
                        showNotification(`${selectedTicker} n'a pas d'options disponibles pour la volatilité 3D`, 'warning');
                    }
                }
            }
        });
    }
    
    // Mettre à jour les providers aussi pour le symbole personnalisé
    if (customInput) {
        customInput.addEventListener('input', () => {
            const symbol = customInput.value.trim();
            if (symbol) {
                updateProviderOptions(symbol);
            }
        });
    }
    
    // Fonction pour mettre à jour la barre de progression et les étapes
    function updateProgress(step, totalSteps, message) {
        const progressFill = document.getElementById('vs-progress-fill');
        const progressPercentage = document.getElementById('vs-progress-percentage');
        const loadingText = document.getElementById('vs-loading-text');
        
        if (progressFill && progressPercentage && loadingText) {
            const percentage = Math.round((step / totalSteps) * 100);
            progressFill.style.width = `${percentage}%`;
            progressPercentage.textContent = `${percentage}%`;
            loadingText.textContent = message;
        }
        
        // Mettre à jour les étapes (4 carrés)
        updateStepSquares(step);
    }
    
    // Fonction pour mettre à jour les carrés d'étapes
    function updateStepSquares(currentStep) {
        const steps = [
            { id: 'step-1', label: 'Verification' },
            { id: 'step-2', label: 'API Connection' },
            { id: 'step-3', label: 'Data Retrieval' },
            { id: 'step-4', label: 'Calculation' }
        ];
        
        steps.forEach((step, index) => {
            const stepElement = document.getElementById(step.id);
            if (stepElement) {
                // Retirer toutes les classes
                stepElement.classList.remove('active', 'completed');
                
                // Ajouter la classe appropriée
                if (index + 1 < currentStep) {
                    // Étape terminée
                    stepElement.classList.add('completed');
                } else if (index + 1 === currentStep) {
                    // Étape active
                    stepElement.classList.add('active');
                }
            }
        });
    }
    
    // Fonction pour simuler les étapes de chargement
    async function simulateLoadingSteps(symbol, span, provider) {
        const steps = [
            { step: 1, message: 'Verification du symbole...' },
            { step: 2, message: 'Connecting to API...' },
            { step: 3, message: 'Retrieving options data...' },
            { step: 4, message: 'Calculating implied volatilities...' }
        ];
        
        const totalSteps = steps.length;
        
        // Simuler les étapes avec des délais variables
        for (let i = 0; i < steps.length - 1; i++) { // S'arrêter avant la dernière étape
            updateProgress(steps[i].step, totalSteps, steps[i].message);
            
            // Délai variable selon l'étape
            let delay;
                    if (i === 0) delay = 400; // Verification
        else if (i === 1) delay = 600; // API Connection
        else if (i === 2) delay = 1000; // Data Retrieval (longer)
            
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        // La dernière étape sera gérée après le chargement réel
    }
    
    // Fonction pour charger les données de volatilité surface 3D
    async function fetchVolatilitySurface(symbol, span, provider) {
        // Pré-valider le ticker pour éviter les erreurs 404
        const hasOptions = await validateTickerHasOptions(symbol);
        if (!hasOptions) {
            console.log(`ℹ️ ${symbol} pré-validé pour Volatility 3D: pas d'options disponibles (évite 404)`);
            throw new Error(`${symbol} n'a pas d'options disponibles pour la volatilité 3D`);
        }
        
        let url;
        
        // Choisir l'endpoint selon le provider
        if (provider === 'tradier') {
            url = `/api/vol-surface-3d-tradier-simple/${encodeURIComponent(symbol)}?span=${span}&_t=${Date.now()}`;
        } else {
            // Provider par défaut (tradier)
            url = `/api/vol-surface-3d-tradier-simple/${encodeURIComponent(symbol)}?span=${span}&_t=${Date.now()}`;
        }
        
        try {
            const response = await fetch(url);
            if (!response.ok) {
                if (response.status === 404) {
                    // Ticker sans options disponibles (cas rare après pré-validation)
                    console.warn(`⚠️ ${symbol} n'a pas d'options disponibles pour Volatility 3D (404 inattendu)`);
                    tickerValidationCache.set(symbol, false); // Mettre à jour le cache
                    throw new Error(`${symbol} n'a pas d'options disponibles pour la volatilité 3D`);
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            return data;
        } catch (error) {
            console.error('Error fetching volatility surface 3D:', error);
            throw error;
        }
    }
    
    // Gestion du bouton de chargement
    const vsLoadBtn = document.getElementById('vs-load');
    if (vsLoadBtn) {
        vsLoadBtn.addEventListener('click', async () => {
        try {
            const symbol = getCurrentSymbol();
            if (!symbol) {
                showNotification('Veuillez choisir un ticker.', 'error');
                return;
            }
            
            const span = parseFloat(document.getElementById('vs-span').value) || 0.5;
            const provider = document.getElementById('vs-provider').value || 'tradier';
            
            
            updateApiStatus('checking');
            
            const plotDiv = document.getElementById('vs-plot');
            const placeholder = document.getElementById('vs-plot-placeholder');
            
            if (placeholder) {
                placeholder.innerHTML = `
                    <div class="volatility-3d-loading">
                        <div class="loading-square">
                            <!-- Barre de chargement en haut -->
                            <div class="loading-bar-container">
                                <div class="loading-bar">
                                    <div class="loading-bar-fill" id="vs-progress-fill"></div>
                                </div>
                                <div class="loading-percentage" id="vs-progress-percentage">0%</div>
                            </div>
                            
                            <!-- 4 sous-carrés pour les étapes -->
                            <div class="steps-grid">
                                <div class="step-square" id="step-1">
                                    <div class="step-number">1</div>
                                    <div class="step-label">Verification</div>
                                </div>
                                <div class="step-square" id="step-2">
                                    <div class="step-number">2</div>
                                    <div class="step-label">API Connection</div>
                                </div>
                                <div class="step-square" id="step-3">
                                    <div class="step-number">3</div>
                                    <div class="step-label">Data Retrieval</div>
                                </div>
                                <div class="step-square" id="step-4">
                                    <div class="step-number">4</div>
                                    <div class="step-label">Calculation</div>
                                </div>
                            </div>
                            
                            <!-- Message de statut -->
                            <div class="loading-status" id="vs-loading-text">Preparing loading...</div>
                        </div>
                    </div>`;
            }
            
            // Démarrer la simulation de chargement en parallèle
            const loadingPromise = simulateLoadingSteps(symbol, span, provider);
            
            const startTime = performance.now();
            const res = await fetchVolatilitySurface(symbol, span, provider);
            const endTime = performance.now();
            const responseTime = Math.round(endTime - startTime);
            
            // Finaliser la progression après le chargement réel
            updateProgress(4, 4, 'Loading completed!');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Attendre que la simulation de chargement soit terminée
            await loadingPromise;
            
            
            if (res && !res.error) {
                updateApiStatus('connected', responseTime);
                
                // Stocker les données actuelles pour les contrôles
                window.currentVolatilityData = res;
                
                // Note: Section "Paramètres de Calcul" supprimée selon la demande utilisateur
                // document.getElementById('vs-parameters').classList.remove('hidden');
                
                // Mettre à jour les métriques
                if (res.spot_price) {
                    document.getElementById('vs-spot-price').textContent = `$${res.spot_price.toFixed(2)}`;
                }
                // Nettoyer le texte de la source pour supprimer "(Données Réelles)"
                let sourceText = provider.toUpperCase();
                sourceText = sourceText.replace(/\s*\(Données Réelles\)\s*/g, '');
                document.getElementById('vs-data-source').textContent = sourceText;
                document.getElementById('vs-maturities-count').textContent = res.maturities ? res.maturities.length : '-';
                document.getElementById('vs-strikes-count').textContent = res.strikes ? res.strikes.length : '-';
                
                // Calculer les statistiques IV
                if (res.iv && res.iv.length > 0) {
                    const ivs = res.iv.flat().filter(v => v !== null && !isNaN(v));
                    if (ivs.length > 0) {
                        const minIV = Math.min(...ivs);
                        const maxIV = Math.max(...ivs);
                        const avgIV = ivs.reduce((a, b) => a + b, 0) / ivs.length;
                        
                        document.getElementById('vs-iv-min').textContent = `${(minIV * 100).toFixed(2)}%`;
                        document.getElementById('vs-iv-max').textContent = `${(maxIV * 100).toFixed(2)}%`;
                        document.getElementById('vs-iv-avg').textContent = `${(avgIV * 100).toFixed(2)}%`;
                    }
                }
                
                // Créer le graphique 3D
                create3DVolatilitySurface(res, symbol);
                
                // Supprimer le spinner de chargement
                if (placeholder) {
                    placeholder.innerHTML = '';
                }
                
                // Afficher les statistiques dans la section debug (pas sous le graphique)
                // Les statistiques sont maintenant gérées dans updateDebugSection()
                
                // Afficher la section debug
                document.getElementById('debug-json-section').classList.remove('hidden');
                updateDebugSection(res, symbol);
                
            } else {
                updateApiStatus('error');
                
                // Supprimer le spinner de chargement en cas d'erreur
                if (placeholder) {
                    placeholder.innerHTML = '';
                }
                
                let errorMessage = res.error || 'Error loading data';
                
                // Messages d'erreur plus informatifs
                if (errorMessage.includes('Aucune date d\'expiration')) {
                    errorMessage = `Aucune option disponible pour ${symbol}. Essayez SPY, QQQ ou IWM qui ont généralement plus de données d'options.`;
                } else if (errorMessage.includes('Aucune option')) {
                    errorMessage = `Aucune option trouvée pour ${symbol}. Vérifiez que le symbole est correct et qu'il a des options disponibles.`;
                }
                
                plotDiv.innerHTML = `
                                                <div class="volatility-3d-error">
                                <div class="volatility-3d-error-icon">
                                    <i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i>
                                </div>
                        <div class="volatility-3d-error-title">Loading Error</div>
                        <div class="volatility-3d-error-message">${errorMessage}</div>
                        <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(55, 65, 81, 0.5); border-radius: 0.5rem; border: 1px solid #374151;">
                            <h5 style="color: #3b82f6; margin-bottom: 0.75rem;">
                                <i data-lucide="lightbulb" style="width: 16px; height: 16px; margin-right: 0.5rem;"></i>
                                Suggestions :
                            </h5>
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: #d1d5db; font-size: 0.875rem;">
                                <li>Essayez SPY, QQQ ou IWM (ETF avec beaucoup d'options)</li>
                                <li>Vérifiez que le symbole est correct</li>
                                <li>Reduce the number of maturities (maxExp)</li>
                                <li>Augmentez l'écart autour du spot (span)</li>
                            </ul>
                        </div>
                        <div style="margin-top: 1rem; padding: 1rem; background: rgba(31, 41, 55, 0.5); border: 1px solid #374151; border-radius: 0.5rem;">
                            <h5 style="color: #3b82f6; margin-bottom: 0.75rem;">
                                <i data-lucide="search" style="width: 16px; height: 16px; margin-right: 0.5rem;"></i>
                                Données brutes reçues :
                            </h5>
                            <pre style="color: #9ca3af; font-size: 0.75rem; overflow-x: auto; white-space: pre-wrap; background: rgba(0, 0, 0, 0.3); padding: 0.75rem; border-radius: 0.375rem;">${JSON.stringify(res, null, 2)}</pre>
                        </div>
                    </div>`;
            }
                 } catch (e) {
             console.error('Erreur lors du chargement:', e);
             updateApiStatus('error');
             const plotDiv = document.getElementById('vs-plot');
             plotDiv.innerHTML = `<div class="error-message">Connection error: ${e.message}</div>`;
         }
     });
     }
     

    
    // Fonction pour créer le graphique 3D avec fond transparent
    function create3DVolatilitySurface(data, symbol) {
        const plotDiv = document.getElementById('vs-plot');
        
        
        if (!data.iv || !data.maturities || !data.strikes) {
                            plotDiv.innerHTML = '<div class="volatility-3d-error"><div class="volatility-3d-error-icon"><i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i></div><div class="volatility-3d-error-title">Insufficient Data</div><div class="volatility-3d-error-message">Implied volatility data is not sufficient to create the 3D chart</div></div>';
            return;
        }
        
        // Convert strikes to percentage of spot price for tooltips
        const spotPrice = data.spot_price || 100;
        const x = data.strikes.map(strike => (strike / spotPrice) * 100); // Convert to percentage
        const y = data.maturities; // Déjà en années
        const z = data.iv; // Matrice 2D déjà formatée
        
        // Control parameters (default values)
        const viewType = 'surface';
        const colorscale = 'Viridis';
        
        // Create main surface trace
        let trace;
        
        if (viewType === 'wireframe') {
            trace = {
                x: x,
                y: y,
                z: z,
                type: 'surface',
                colorscale: colorscale,
                name: 'Implied Volatility',
                hovertemplate: (
                    '<b>Strike:</b> %{x:.1f}% of spot<br>' +
                    '<b>Maturity:</b> %{y:.2f} years<br>' +
                    '<b>IV:</b> %{z:.2%}<br>' +
                    '<extra></extra>'
                ),
                showscale: true,
                colorbar: {
                    title: "Implied Volatility",
                    titleside: "right",
                    tickformat: ".1%",
                    len: 0.8
                },
                opacity: 0.8,
                contours: {
                    z: {
                        show: true,
                        usecolormap: true,
                        highlightcolor: "#42f462",
                        project: {z: true}
                    }
                }
            };
        } else if (viewType === 'contour') {
            trace = {
                x: x,
                y: y,
                z: z,
                type: 'contour',
                colorscale: colorscale,
                name: 'Implied Volatility',
                hovertemplate: (
                    '<b>Strike:</b> %{x:.1f}% of spot<br>' +
                    '<b>Maturity:</b> %{y:.2f} years<br>' +
                    '<b>IV:</b> %{z:.2%}<br>' +
                    '<extra></extra>'
                ),
                showscale: true,
                colorbar: {
                    title: "Implied Volatility",
                    titleside: "right",
                    tickformat: ".1%",
                    len: 0.8
                },
                contours: {
                    coloring: 'heatmap',
                    showlabels: true
                }
            };
        } else {
            // Default surface view
            trace = {
                x: x,
                y: y,
                z: z,
                type: 'surface',
                colorscale: colorscale,
                name: 'Implied Volatility',
                hovertemplate: (
                    '<b>Strike:</b> %{x:.1f}% of spot<br>' +
                    '<b>Maturity:</b> %{y:.2f} years<br>' +
                    '<b>IV:</b> %{z:.2%}<br>' +
                    '<extra></extra>'
                ),
                showscale: true,
                colorbar: {
                    title: "Implied Volatility",
                    titleside: "right",
                    tickformat: ".1%",
                    len: 0.8
                }
            };
        }
        
        const traces = [trace];
        
        // Note: Spot price line removed as per user request
        
        // Fonction pour obtenir les tailles responsive pour le graphique 3D
        function getResponsiveSizes3D() {
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            const isTinyMobile = window.innerWidth <= 360;
            const isTablet = window.innerWidth <= 1024 && window.innerWidth > 768;
            const isDesktop = window.innerWidth > 1024;
            
            let titleSize, axisTitleSize, tickSize, legendSize;
            
            if (isTinyMobile) {
                titleSize = 14;
                axisTitleSize = 10;
                tickSize = 8;
                legendSize = 9;
            } else if (isSmallMobile) {
                titleSize = 16;
                axisTitleSize = 11;
                tickSize = 9;
                legendSize = 10;
            } else if (isMobile) {
                titleSize = 18;
                axisTitleSize = 12;
                tickSize = 10;
                legendSize = 11;
            } else if (isTablet) {
                titleSize = 20;
                axisTitleSize = 13;
                tickSize = 11;
                legendSize = 12;
            } else {
                titleSize = 22;
                axisTitleSize = 14;
                tickSize = 12;
                legendSize = 13;
            }
            
            return {
                titleSize,
                axisTitleSize,
                tickSize,
                legendSize,
                isMobile,
                isSmallMobile,
                isTinyMobile,
                isTablet,
                isDesktop
            };
        }
        
        const responsiveSizes3D = getResponsiveSizes3D();
        
        // Layout with transparent background and improved styles and responsive
        const layout = {
            title: {
                text: `Implied Volatility Analysis - ${symbol}`,
                font: { 
                    color: '#ffffff', 
                    size: responsiveSizes3D.titleSize, 
                    family: 'Segoe UI' 
                },
                x: 0.5,
                xanchor: 'center',
                pad: { t: 10, b: 10 }
            },
            scene: {
                xaxis: {
                    title: 'Strike (% of Spot)',
                    gridcolor: 'rgba(55, 65, 81, 0.3)',
                    zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                    showbackground: false,
                    titlefont: { 
                        color: '#ffffff', 
                        size: responsiveSizes3D.axisTitleSize, 
                        family: 'Segoe UI' 
                    },
                    tickfont: { 
                        color: '#d1d5db', 
                        size: responsiveSizes3D.tickSize, 
                        family: 'Segoe UI' 
                    },
                    showgrid: true,
                    zeroline: true
                },
                yaxis: {
                    title: 'Maturity (years)',
                    gridcolor: 'rgba(55, 65, 81, 0.3)',
                    zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                    showbackground: false,
                    titlefont: { 
                        color: '#ffffff', 
                        size: responsiveSizes3D.axisTitleSize, 
                        family: 'Segoe UI' 
                    },
                    tickfont: { 
                        color: '#d1d5db', 
                        size: responsiveSizes3D.tickSize, 
                        family: 'Segoe UI' 
                    },
                    showgrid: true,
                    zeroline: true
                },
                zaxis: {
                    title: 'Implied Volatility',
                    gridcolor: 'rgba(55, 65, 81, 0.3)',
                    zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                    tickformat: '.1%',
                    showbackground: false,
                    titlefont: { 
                        color: '#ffffff', 
                        size: responsiveSizes3D.axisTitleSize, 
                        family: 'Segoe UI' 
                    },
                    tickfont: { 
                        color: '#d1d5db', 
                        size: responsiveSizes3D.tickSize, 
                        family: 'Segoe UI' 
                    },
                    showgrid: true,
                    zeroline: true
                },
                camera: {
                    eye: {x: 1.5, y: 1.5, z: 1.5},
                    center: {x: 0, y: 0, z: 0}
                },
                bgcolor: 'rgba(0,0,0,0)', // Transparent background
                aspectmode: 'cube',
                // Configuration spécifique pour les tooltips 3D
                hovermode: 'closest',
                hoverlabel: {
                    bgcolor: 'rgba(17, 24, 39, 0.95)',
                    bordercolor: '#374151',
                    font: {
                        color: '#f9fafb',
                        size: 12
                    }
                }
            },
            paper_bgcolor: 'rgba(0,0,0,0)', // Fond transparent
            plot_bgcolor: 'rgba(0,0,0,0)',  // Fond transparent
            font: {
                color: '#ffffff',
                family: 'Segoe UI'
            },
            margin: {
                l: 50,
                r: 50,
                b: 50,
                t: 80
            },
            showlegend: true,
            hovermode: 'closest', // Activer les tooltips au survol
            hoverlabel: {
                bgcolor: 'rgba(17, 24, 39, 0.95)',
                bordercolor: '#374151',
                font: {
                    color: '#f9fafb',
                    size: 12
                }
            },
            legend: {
                font: { color: '#ffffff', size: 12, family: 'Segoe UI' },
                bgcolor: 'rgba(0,0,0,0.6)',
                bordercolor: 'rgba(55, 65, 81, 0.5)',
                borderwidth: 1,
                x: 0.02,
                y: 0.98,
                xanchor: 'left',
                yanchor: 'top'
            }
        };
        
        // Optimized Plotly configuration
        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'], // Supprimé 'hoverClosest2d' pour activer les tooltips
            displaylogo: false,
            hovermode: 'closest', // Activer les tooltips au survol
            hoverlabel: {
                bgcolor: 'rgba(17, 24, 39, 0.95)',
                bordercolor: '#374151',
                font: {
                    color: '#f9fafb',
                    size: 12
                }
            },
            // Options spécifiques pour forcer les tooltips
            doubleClick: 'reset+autosize',
            showTips: true,
            showLink: false,
            // Forcer l'affichage des tooltips
            staticPlot: false,
            editable: false,
            toImageButtonOptions: {
                format: 'png',
                filename: `volatility_surface_3d_${symbol}`,
                height: 800,
                width: 1200,
                scale: 2
            },
            modeBarButtonsToAdd: [{
                name: 'Reset View',
                icon: Plotly.Icons.undo,
                click: function() {
                    Plotly.relayout(plotDiv, {
                        'scene.camera.eye': {x: 1.5, y: 1.5, z: 1.5},
                        'scene.camera.center': {x: 0, y: 0, z: 0}
                    });
                }
            }]
        };
        
        // Ajuster les marges et tailles selon la taille d'écran pour le graphique 3D
        function adjustMarginsForScreenSize() {
            // Vérifier que layout est défini avant d'y accéder
            if (typeof layout === 'undefined' || !layout || !layout.margin) {
                console.warn('adjustMarginsForScreenSize: layout ou layout.margin non défini');
                return;
            }
            
            const responsiveSizes3D = getResponsiveSizes3D();
            
            if (responsiveSizes3D.isTinyMobile) {
                layout.margin.r = 10;
                layout.margin.l = 15;
                layout.margin.t = 50;
                layout.margin.b = 30;
            } else if (responsiveSizes3D.isSmallMobile) {
                layout.margin.r = 15;
                layout.margin.l = 20;
                layout.margin.t = 60;
                layout.margin.b = 35;
            } else if (responsiveSizes3D.isMobile) {
                layout.margin.r = 20;
                layout.margin.l = 25;
                layout.margin.t = 70;
                layout.margin.b = 40;
            } else if (responsiveSizes3D.isTablet) {
                layout.margin.r = 40;
                layout.margin.l = 40;
                layout.margin.t = 75;
                layout.margin.b = 45;
            } else {
                layout.margin.r = 80; // Marge normale pour la barre de couleur sur grand écran
                layout.margin.l = 50;
                layout.margin.t = 80;
                layout.margin.b = 50;
            }
            
            // Mettre à jour les tailles de police (avec vérifications)
            if (layout.title && layout.title.font) {
                layout.title.font.size = responsiveSizes3D.titleSize;
            }
            if (layout.scene && layout.scene.xaxis && layout.scene.xaxis.titlefont) {
                layout.scene.xaxis.titlefont.size = responsiveSizes3D.axisTitleSize;
            }
            if (layout.scene && layout.scene.xaxis && layout.scene.xaxis.tickfont) {
                layout.scene.xaxis.tickfont.size = responsiveSizes3D.tickSize;
            }
            if (layout.scene && layout.scene.yaxis && layout.scene.yaxis.titlefont) {
                layout.scene.yaxis.titlefont.size = responsiveSizes3D.axisTitleSize;
            }
            if (layout.scene && layout.scene.yaxis && layout.scene.yaxis.tickfont) {
                layout.scene.yaxis.tickfont.size = responsiveSizes3D.tickSize;
            }
            if (layout.scene && layout.scene.zaxis && layout.scene.zaxis.titlefont) {
                layout.scene.zaxis.titlefont.size = responsiveSizes3D.axisTitleSize;
            }
            if (layout.scene && layout.scene.zaxis && layout.scene.zaxis.tickfont) {
                layout.scene.zaxis.tickfont.size = responsiveSizes3D.tickSize;
            }
            if (layout.legend && layout.legend.font) {
                layout.legend.font.size = responsiveSizes3D.legendSize;
            }
            
            // Masquer la barre de couleur sur mobile, l'afficher sur grand écran
            traces.forEach(trace => {
                if (trace.showscale !== undefined) {
                    trace.showscale = !responsiveSizes3D.isMobile; // true sur grand écran, false sur mobile
                }
            });
        }
        
        // Ajuster les marges avant de créer le graphique
        if (typeof layout !== 'undefined' && layout.margin) {
            adjustMarginsForScreenSize();
        }
        
        // Utiliser la configuration de la classe si disponible
        if (data.plot_config) {
            Object.assign(config, data.plot_config);
        }
        
        Plotly.newPlot(plotDiv, traces, layout, config);
        
        // Forcer l'activation des tooltips après la création du graphique
        setTimeout(() => {
            // Réactiver les tooltips si nécessaire
            Plotly.relayout(plotDiv, {
                'hovermode': 'closest',
                'scene.hovermode': 'closest'
            });
            
            // Ajouter un événement pour s'assurer que les tooltips fonctionnent
            plotDiv.on('plotly_hover', function(data) {
                console.log('Tooltip hover activé:', data);
            });
            
            // Forcer l'activation des tooltips sur les traces
            if (plotDiv.data && plotDiv.data.length > 0) {
                for (let i = 0; i < plotDiv.data.length; i++) {
                    if (plotDiv.data[i].type === 'surface') {
                        Plotly.restyle(plotDiv, {
                            'hoverinfo': 'all',
                            'hovertemplate': plotDiv.data[i].hovertemplate
                        }, [i]);
                    }
                }
            }
            
            console.log('✅ Tooltips 3D activés et configurés');
        }, 100);
        
        // Forcer le redimensionnement après le chargement
        setTimeout(() => {
            if (plotDiv && plotDiv.data && typeof layout !== 'undefined' && layout.margin) {
                adjustMarginsForScreenSize();
                Plotly.relayout(plotDiv, {
                    'margin.r': layout.margin.r,
                    'margin.l': layout.margin.l,
                    'margin.t': layout.margin.t,
                    'margin.b': layout.margin.b
                });
                
                // Masquer la barre de couleur sur mobile via CSS
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    const colorbars = plotDiv.querySelectorAll('.colorbar');
                    colorbars.forEach(colorbar => {
                        colorbar.style.display = 'none';
                        colorbar.style.visibility = 'hidden';
                        colorbar.style.width = '0';
                        colorbar.style.height = '0';
                    });
                }
            }
        }, 500);
        
        // Gestionnaire pour redimensionner le graphique quand la fenêtre change
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                if (plotDiv && plotDiv.data && typeof layout !== 'undefined' && layout.margin) {
                    adjustMarginsForScreenSize();
                    Plotly.relayout(plotDiv, {
                        'margin.r': layout.margin.r,
                        'margin.l': layout.margin.l,
                        'margin.t': layout.margin.t,
                        'margin.b': layout.margin.b,
                        'title.font.size': layout.title.font.size,
                        'scene.xaxis.titlefont.size': layout.scene.xaxis.titlefont.size,
                        'scene.xaxis.tickfont.size': layout.scene.xaxis.tickfont.size,
                        'scene.yaxis.titlefont.size': layout.scene.yaxis.titlefont.size,
                        'scene.yaxis.tickfont.size': layout.scene.yaxis.tickfont.size,
                        'scene.zaxis.titlefont.size': layout.scene.zaxis.titlefont.size,
                        'scene.zaxis.tickfont.size': layout.scene.zaxis.tickfont.size,
                        'legend.font.size': layout.legend && layout.legend.font ? layout.legend.font.size : 12
                    });
                    
                    // Masquer la barre de couleur sur mobile via CSS
                    const responsiveSizes3D = getResponsiveSizes3D();
                    if (responsiveSizes3D.isMobile) {
                        const colorbars = plotDiv.querySelectorAll('.colorbar');
                        colorbars.forEach(colorbar => {
                            colorbar.style.display = 'none';
                            colorbar.style.visibility = 'hidden';
                            colorbar.style.width = '0';
                            colorbar.style.height = '0';
                        });
                    }
                }
            }, 250);
        });
        
        // Les statistiques sont maintenant affichées dans la section debug
        // Pas besoin d'afficher les statistiques sous le graphique
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
    }
    
        // Fonction displayStatistics supprimée - les statistiques sont maintenant dans la section debug
    
    // ===== SECTION SMILE DE VOLATILITÉ =====
    
    // Gestion des tickers pour la comparaison des sourires (INDÉPENDANTE de la surface 3D)
    let smileComparisonTickers = [];
    let selectedMaturities = new Set();
    let selectedCombinations = [];
    let availableTickers = [];
    let tickerMaturities = {}; // Cache des maturités par ticker
    
    // Variables globales partagées pour assurer la cohérence entre les sections
    let globalAvailableTickers = []; // Source unique de vérité pour tous les tickers
    let tickersLoaded = false; // Flag pour éviter les chargements multiples
    let tickersWithoutOptions = new Set(); // Tickers sans options disponibles
    let tickersWithOptions = new Set(); // Tickers avec options disponibles
    
    // Cache intelligent pour éviter les erreurs 404
    let tickerValidationCache = new Map(); // Cache des validations de tickers
    let tickerValidationInProgress = new Set(); // Tickers en cours de validation
    
    // Cache pour les données de term structure (optimisation performance)
    let termStructureDataCache = new Map(); // Cache des données term structure
    
    // Fonction pour nettoyer le cache de term structure
    function clearTermStructureCache() {
        const cacheSize = termStructureDataCache.size;
        termStructureDataCache.clear();
        console.log(`🗑️ Cache de term structure nettoyé (${cacheSize} entrées supprimées)`);
    }
    
    // Fonction utilitaire pour obtenir la date actuelle en fuseau horaire US
    function getUSToday() {
        const today = new Date();
        return new Date(today.toLocaleString("en-US", {timeZone: "America/New_York"}));
    }
    
    // Fonction utilitaire pour convertir une date en fuseau horaire US
    function toUSDate(date) {
        return new Date(date.toLocaleString("en-US", {timeZone: "America/New_York"}));
    }
    
    // Fonction pour valider un ticker sans générer d'erreur 404
    async function validateTickerHasOptions(ticker) {
        // Vérifier le cache d'abord
        if (tickerValidationCache.has(ticker)) {
            return tickerValidationCache.get(ticker);
        }
        
        // Éviter les validations multiples simultanées
        if (tickerValidationInProgress.has(ticker)) {
            // Attendre que la validation en cours se termine
            while (tickerValidationInProgress.has(ticker)) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return tickerValidationCache.get(ticker) || false;
        }
        
        tickerValidationInProgress.add(ticker);
        
        try {
            // Utiliser une requête GET normale mais avec gestion intelligente des erreurs
            const response = await fetch(`/api/tradier/expirations/${ticker}`, {
                method: 'GET',
                timeout: 5000
            });
            
            if (response.status === 404) {
                // Ticker sans options - pas d'erreur, juste un résultat
                console.log(`ℹ️ ${ticker} n'a pas d'options disponibles (404 détecté silencieusement)`);
                tickerValidationCache.set(ticker, false);
                tickersWithoutOptions.add(ticker);
                return false;
            }
            
            if (!response.ok) {
                // Autre erreur HTTP
                console.warn(`⚠️ Erreur HTTP ${response.status} pour ${ticker}`);
                tickerValidationCache.set(ticker, false);
                tickersWithoutOptions.add(ticker);
                return false;
            }
            
            // Vérifier que la réponse contient des données valides
            const data = await response.json();
            const hasOptions = data && data.success && data.expirations && data.expirations.length > 0;
            
            // Mettre en cache le résultat
            tickerValidationCache.set(ticker, hasOptions);
            
            if (hasOptions) {
                tickersWithOptions.add(ticker);
                console.log(`✅ ${ticker} validé: a des options disponibles`);
            } else {
                tickersWithoutOptions.add(ticker);
                console.log(`⚠️ ${ticker} validé: pas d'options disponibles`);
            }
            
            return hasOptions;
            
        } catch (error) {
            // En cas d'erreur réseau ou autre, considérer comme ticker sans options
            console.warn(`⚠️ Erreur lors de la validation de ${ticker}:`, error.message);
            tickerValidationCache.set(ticker, false);
            tickersWithoutOptions.add(ticker);
            return false;
        } finally {
            tickerValidationInProgress.delete(ticker);
        }
    }
    
    // Fonction pour synchroniser les tickers entre toutes les sections
    function synchronizeTickers() {
        // S'assurer que toutes les sections utilisent les mêmes tickers disponibles
        availableTickers = globalAvailableTickers;
        termStructureAvailableTickers = globalAvailableTickers;
        
        // Mettre à jour les dropdowns de toutes les sections
        updateTickerDropdown();
        updateTermStructureTickerDropdown();
        updateVolatility3DSymbolSelect();
        
        console.log(`🔄 Tickers synchronisés: ${globalAvailableTickers.length} tickers disponibles pour toutes les sections`);
        
        // Mettre à jour les compteurs de tickers dans l'interface
        updateTickerCounts();
    }
    
    // Fonction pour mettre à jour les compteurs de tickers dans l'interface
    function updateTickerCounts() {
        // Mettre à jour le compteur pour la section smile
        const smileCount = document.getElementById('smile-ticker-count');
        if (smileCount) {
            smileCount.textContent = smileComparisonTickers.length.toString();
        }
        
        // Mettre à jour le compteur pour la section term structure
        const termStructureCount = document.getElementById('term-structure-ticker-count');
        if (termStructureCount) {
            termStructureCount.textContent = termStructureTickers.length.toString();
        }
        
        // Afficher le nombre de tickers disponibles pour la volatilité 3D
        const volatility3DSelect = document.getElementById('vs-symbol-select');
        if (volatility3DSelect) {
            const availableOptions = volatility3DSelect.options.length - 1; // -1 pour l'option "Custom"
            console.log(`📊 Volatilité 3D: ${availableOptions} tickers disponibles`);
        }
        
        // Afficher les statistiques des tickers avec/sans options
        if (tickersWithoutOptions.size > 0) {
            console.log(`⚠️ ${tickersWithoutOptions.size} tickers sans options détectés: [${Array.from(tickersWithoutOptions).join(', ')}]`);
        }
        if (tickersWithOptions.size > 0) {
            console.log(`✅ ${tickersWithOptions.size} tickers avec options disponibles: [${Array.from(tickersWithOptions).join(', ')}]`);
        }
        
        // Afficher les statistiques du cache de validation
        if (tickerValidationCache.size > 0) {
            console.log(`📊 Cache de validation: ${tickerValidationCache.size} tickers validés (évite les erreurs 404)`);
            
            // Afficher le pourcentage de tickers avec options
            const totalValidated = tickerValidationCache.size;
            const withOptions = Array.from(tickerValidationCache.entries()).filter(([ticker, hasOptions]) => hasOptions).length;
            const withoutOptions = totalValidated - withOptions;
            const percentageWithOptions = totalValidated > 0 ? Math.round((withOptions / totalValidated) * 100) : 0;
            
            console.log(`📈 Statistiques de validation:`);
            console.log(`   • ${withOptions} tickers avec options (${percentageWithOptions}%)`);
            console.log(`   • ${withoutOptions} tickers sans options (${100 - percentageWithOptions}%)`);
        }
        
        // Afficher un message de confirmation si les sections ont le même nombre de tickers
        if (smileComparisonTickers.length === termStructureTickers.length && smileComparisonTickers.length > 0) {
            console.log(`✅ Synchronisation réussie: ${smileComparisonTickers.length} tickers dans les sections de comparaison`);
        } else if (smileComparisonTickers.length !== termStructureTickers.length) {
            console.warn(`⚠️ Désynchronisation détectée: Smile=${smileComparisonTickers.length}, Term Structure=${termStructureTickers.length}`);
        }
    }
    
    // Fonction pour filtrer les tickers sans options de la liste globale
    function filterTickersWithoutOptions() {
        if (tickersWithoutOptions.size > 0) {
            console.log(`🔍 Filtrage de ${tickersWithoutOptions.size} tickers sans options...`);
            
            // Filtrer la liste globale
            const originalCount = globalAvailableTickers.length;
            globalAvailableTickers = globalAvailableTickers.filter(ticker => 
                !tickersWithoutOptions.has(ticker.symbol)
            );
            
            console.log(`📊 Tickers filtrés: ${originalCount} → ${globalAvailableTickers.length} (${originalCount - globalAvailableTickers.length} supprimés)`);
            
            // Mettre à jour toutes les sections
            synchronizeTickers();
            
            // Afficher un message à l'utilisateur
            showNotification(`${originalCount - globalAvailableTickers.length} tickers sans options ont été filtrés`, 'info');
        }
    }
    
    // Fonction pour calculer la date de maturité (avec fuseau horaire US)
    function getMaturityDate(days) {
        // Utiliser le fuseau horaire des États-Unis (EST/EDT)
        const usToday = getUSToday();
        const maturityDate = new Date(usToday);
        maturityDate.setDate(usToday.getDate() + days);
        
        // Formater la date en DD/MM/YYYY
        const day = maturityDate.getDate().toString().padStart(2, '0');
        const month = (maturityDate.getMonth() + 1).toString().padStart(2, '0');
        const year = maturityDate.getFullYear();
        
        return `${day}/${month}/${year}`;
    }
    
    // Fonction globale pour charger les tickers disponibles depuis l'API (source unique de vérité)
    async function loadGlobalAvailableTickers() {
        // Éviter les chargements multiples
        if (tickersLoaded && globalAvailableTickers.length > 0) {
            console.log('✅ Tickers déjà chargés, utilisation du cache');
            return globalAvailableTickers;
        }
        
        try {
            console.log('🔄 Chargement des tickers depuis l\'API...');
            const response = await fetch('/api/available-symbols');
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data && data.recommended_symbols) {
                // Utiliser directement la structure recommended_symbols
                globalAvailableTickers = data.recommended_symbols;
                tickersLoaded = true;
                console.log(`✅ ${globalAvailableTickers.length} tickers chargés depuis l'API`);
            } else {
                console.warn('⚠️ Aucun ticker disponible trouvé dans la réponse');
                // Fallback vers une liste statique si l'API échoue
                globalAvailableTickers = [
                    {symbol: 'AAPL', label: 'AAPL - Apple Inc.'},
                    {symbol: 'MSFT', label: 'MSFT - Microsoft Corp.'},
                    {symbol: 'GOOGL', label: 'GOOGL - Alphabet Inc.'},
                    {symbol: 'AMZN', label: 'AMZN - Amazon.com Inc.'},
                    {symbol: 'TSLA', label: 'TSLA - Tesla Inc.'},
                    {symbol: 'META', label: 'META - Meta Platforms Inc.'},
                    {symbol: 'NVDA', label: 'NVDA - NVIDIA Corp.'},
                    {symbol: 'SPY', label: 'SPY - SPDR S&P 500 ETF'},
                    {symbol: 'QQQ', label: 'QQQ - Invesco QQQ Trust'},
                    {symbol: 'IWM', label: 'IWM - iShares Russell 2000 ETF'},
                    {symbol: 'NFLX', label: 'NFLX - Netflix Inc.'},
                    {symbol: 'AMD', label: 'AMD - Advanced Micro Devices'},
                    {symbol: 'INTC', label: 'INTC - Intel Corp.'},
                    {symbol: 'CRM', label: 'CRM - Salesforce Inc.'}
                ];
                tickersLoaded = true;
                console.log(`✅ ${globalAvailableTickers.length} tickers de fallback chargés`);
            }
        } catch (error) {
            console.error('❌ Erreur lors du chargement des tickers:', error);
            // Fallback vers une liste statique
            globalAvailableTickers = [
                {symbol: 'AAPL', label: 'AAPL - Apple Inc.'},
                {symbol: 'MSFT', label: 'MSFT - Microsoft Corp.'},
                {symbol: 'GOOGL', label: 'GOOGL - Alphabet Inc.'},
                {symbol: 'AMZN', label: 'AMZN - Amazon.com Inc.'},
                {symbol: 'TSLA', label: 'TSLA - Tesla Inc.'},
                {symbol: 'META', label: 'META - Meta Platforms Inc.'},
                {symbol: 'NVDA', label: 'NVDA - NVIDIA Corp.'},
                {symbol: 'SPY', label: 'SPY - SPDR S&P 500 ETF'},
                {symbol: 'QQQ', label: 'QQQ - Invesco QQQ Trust'},
                {symbol: 'IWM', label: 'IWM - iShares Russell 2000 ETF'},
                {symbol: 'NFLX', label: 'NFLX - Netflix Inc.'},
                {symbol: 'AMD', label: 'AMD - Advanced Micro Devices'},
                {symbol: 'INTC', label: 'INTC - Intel Corp.'},
                {symbol: 'CRM', label: 'CRM - Salesforce Inc.'}
            ];
            tickersLoaded = true;
            console.log(`✅ ${globalAvailableTickers.length} tickers de fallback chargés après erreur`);
        }
        
        return globalAvailableTickers;
    }

    // Fonction pour charger les tickers disponibles depuis l'API (pour la section smile)
    async function loadAvailableTickers() {
        await loadGlobalAvailableTickers();
        synchronizeTickers();
    }
    
    // Fonction pour mettre à jour le dropdown des tickers
    function updateTickerDropdown() {
        const select = document.getElementById('smile-ticker-select');
        if (!select) {
            console.error('❌ Élément smile-ticker-select non trouvé');
            return;
        }
        
        
        // Vider les options existantes (garder la première option)
        select.innerHTML = '<option value="">Choose a ticker to add...</option>';
        
        // Ajouter les tickers disponibles
        availableTickers.forEach(tickerData => {
            const option = document.createElement('option');
            option.value = tickerData.symbol;
            option.textContent = tickerData.label || tickerData.symbol;
            select.appendChild(option);
        });
        
    }
    
    // Fonction pour charger les maturités d'un ticker depuis l'API Tradier
    async function loadTickerMaturities(ticker) {
        // Vérifier le cache d'abord
        if (tickerMaturities[ticker]) {
            return tickerMaturities[ticker];
        }
        
        // Pré-valider le ticker pour éviter les erreurs 404
        const hasOptions = await validateTickerHasOptions(ticker);
        if (!hasOptions) {
            console.log(`ℹ️ ${ticker} pré-validé: pas d'options disponibles (évite 404)`);
            tickerMaturities[ticker] = [];
            return [];
        }
        
        try {
            const response = await fetch(`/api/tradier/expirations/${ticker}`);
            
            if (!response.ok) {
                if (response.status === 404) {
                    // Ticker sans options disponibles (cas rare après pré-validation)
                    console.warn(`⚠️ ${ticker} n'a pas d'options disponibles (404 inattendu)`);
                    tickersWithoutOptions.add(ticker);
                    tickerValidationCache.set(ticker, false); // Mettre à jour le cache
                    tickerMaturities[ticker] = [];
                    return [];
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data && data.success && data.expirations && data.expirations.length > 0) {
                // Convertir les dates d'expiration en jours et formater (avec fuseau horaire US)
                const usToday = getUSToday();
                const maturities = data.expirations.map(expItem => {
                    const exp = new Date(expItem.date);
                    const usExp = toUSDate(exp);
                    const days = Math.ceil((usExp - usToday) / (1000 * 60 * 60 * 24));
                    return {
                        days: days,
                        date: expItem.date,
                        display: `${days} days (${getMaturityDate(days)})`
                    };
                }).filter(m => m.days > 0).sort((a, b) => a.days - b.days);
                
                if (maturities.length > 0) {
                    // Ticker avec options disponibles
                    tickersWithOptions.add(ticker);
                tickerMaturities[ticker] = maturities;
                return maturities;
            } else {
                    // Aucune maturité valide
                    console.warn(`⚠️ ${ticker} n'a pas de maturités valides`);
                    tickersWithoutOptions.add(ticker);
                    tickerMaturities[ticker] = [];
                    return [];
                }
            } else {
                // Aucune expiration trouvée
                console.warn(`⚠️ ${ticker} n'a pas d'options disponibles`);
                tickersWithoutOptions.add(ticker);
                tickerMaturities[ticker] = [];
                return [];
            }
        } catch (error) {
            // Gestion intelligente des erreurs selon le type
            if (error.message.includes('404')) {
                console.warn(`⚠️ ${ticker} n'a pas d'options disponibles (404)`);
            } else {
            console.error(`❌ Erreur lors du chargement des maturités pour ${ticker}:`, error);
            }
            // Marquer comme ticker sans options
            tickersWithoutOptions.add(ticker);
            tickerMaturities[ticker] = [];
            return [];
        }
    }
    
    // Fonction pour rendre les tickers sélectionnés
    function renderSelectedTickers() {
        const container = document.getElementById('smile-selected-tickers');
        const countBadge = document.getElementById('smile-ticker-count');
        
        
        if (!container) return;
        
        if (smileComparisonTickers.length === 0) {
            container.innerHTML = `
                <div class="empty-tickers">
                    <i data-lucide="building-2" class="empty-icon"></i>
                    <span>No tickers selected yet</span>
                </div>
            `;
            if (countBadge) countBadge.textContent = '0';
        } else {
            // Méthode plus robuste pour vider le conteneur
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            smileComparisonTickers.forEach(ticker => {
                const chip = document.createElement('div');
                chip.className = 'ticker-chip';
                chip.innerHTML = `
                    <span class="ticker-chip-text">${ticker}</span>
                    <button class="ticker-chip-remove" onclick="removeTicker('${ticker}')">
                        <i data-lucide="x"></i>
                    </button>
                `;
                container.appendChild(chip);
            });
            if (countBadge) countBadge.textContent = smileComparisonTickers.length.toString();
        }
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
    }
    
    // Fonction pour ajouter un ticker
    async function addTicker(ticker) {
        if (!smileComparisonTickers.includes(ticker)) {
            // Pré-valider le ticker pour éviter les erreurs 404
            console.log(`🔍 Validation de ${ticker} avant ajout...`);
            const hasOptions = await validateTickerHasOptions(ticker);
            if (!hasOptions) {
                showNotification(`${ticker} n'a pas d'options disponibles. Ticker ignoré.`, 'warning');
                return;
            }
            
            // Charger les maturités (maintenant sécurisé)
            const maturities = await loadTickerMaturities(ticker);
            
            if (maturities.length === 0) {
                showNotification(`${ticker} n'a pas d'options disponibles. Ticker ignoré.`, 'warning');
                return;
            }
            
            smileComparisonTickers.push(ticker);
            renderSelectedTickers();
            updateCombinationsTable();
            updateTickerCounts(); // Mettre à jour les compteurs
            showNotification(`${ticker} ajouté à la liste`, 'success');
        } else {
            showNotification('Ce ticker est déjà dans la liste.', 'warning');
        }
    }
    
    // Fonction pour supprimer un ticker
    window.removeTicker = function(ticker) {
        smileComparisonTickers = smileComparisonTickers.filter(t => t !== ticker);
        renderSelectedTickers();
        updateCombinationsTable();
        updateGenerateButtonState();
        updateTickerCounts(); // Mettre à jour les compteurs
        showNotification(`${ticker} retiré de la liste`, 'info');
    }
    
    // Fonction pour mettre à jour le tableau des combinaisons
    let isUpdatingTable = false;
    async function updateCombinationsTable() {
        // Éviter les appels multiples simultanés
        if (isUpdatingTable) {
            return;
        }
        
        isUpdatingTable = true;
        
        try {
            // Trouver le tbody du tableau des combinaisons Volatility Smile
            const smileSection = document.querySelector('.volatility-smile-section:not(.term-structure-section)');
            const tbody = smileSection ? smileSection.querySelector('.combinations-table tbody') : null;
            if (!tbody) {
                console.error('❌ Tbody du tableau Volatility Smile non trouvé');
                return;
            }
            
            // Sauvegarder les maturités actuellement sélectionnées avant de vider le tbody
            const currentSelections = {};
            const existingRows = tbody.querySelectorAll('tr');
            existingRows.forEach(row => {
                const tickerCell = row.querySelector('.ticker-display');
                const maturitySelect = row.querySelector('.maturity-select');
                const combinationsDisplay = row.querySelector('.combinations-display');
                
                if (tickerCell && maturitySelect && combinationsDisplay) {
                    const ticker = tickerCell.textContent;
                    const selectedMaturity = maturitySelect.value;
                    const maturityChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                    
                    if (selectedMaturity || maturityChips.length > 0) {
                        currentSelections[ticker] = {
                            selectedMaturity: selectedMaturity,
                            maturityChips: Array.from(maturityChips).map(chip => ({
                                text: chip.querySelector('.ticker-chip-text').textContent,
                                days: chip.dataset.maturity
                            }))
                        };
                    }
                }
            });
            
            // Vider le tbody
            tbody.innerHTML = '';
            
            // Ajouter une ligne pour chaque ticker unique
            const uniqueTickers = [...new Set(smileComparisonTickers)];
            
            for (const ticker of uniqueTickers) {
            const row = document.createElement('tr');
            
            // Charger les maturités pour ce ticker
            const maturities = await loadTickerMaturities(ticker);
            
            // Créer les options du dropdown
            let maturityOptions = '<option value="">Select a maturity...</option>';
            maturities.forEach(maturity => {
                const isSelected = currentSelections[ticker] && currentSelections[ticker].selectedMaturity === maturity.days.toString();
                maturityOptions += `<option value="${maturity.days}" ${isSelected ? 'selected' : ''}>${maturity.display}</option>`;
            });
            
            row.innerHTML = `
                <td class="ticker-cell">
                    <span class="ticker-display">${ticker}</span>
                </td>
                <td class="maturity-cell">
                    <div class="maturity-dropdown-container">
                        <select class="modern-select maturity-select" data-ticker="${ticker}">
                            ${maturityOptions}
                        </select>
                    </div>
                </td>
                <td class="combinations-cell">
                    <div class="tickers-container combinations-display" data-ticker="${ticker}">
                        ${currentSelections[ticker] && currentSelections[ticker].maturityChips.length > 0 ? 
                            currentSelections[ticker].maturityChips.map(chip => `
                                <div class="ticker-chip" data-maturity="${chip.days}">
                                    <span class="ticker-chip-text">${chip.text}</span>
                                    <button class="ticker-chip-remove" onclick="removeMaturityFromTicker('${ticker}', '${chip.days}')">
                                        <i data-lucide="x"></i>
                                    </button>
                                </div>
                            `).join('') :
                            `<div class="empty-tickers">
                                <i data-lucide="layers" class="empty-icon"></i>
                                <span>No maturity selected yet</span>
                            </div>`
                        }
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        }
        
            // Ajouter les event listeners pour les dropdowns de maturité
            addMaturityEventListeners();
            
            // Initialiser les icônes Lucide
            if (window.lucide) {
                lucide.createIcons();
            }
        } catch (error) {
            console.error('Erreur lors de la mise à jour du tableau:', error);
        } finally {
            isUpdatingTable = false;
        }
    }
    
    // Fonction pour ajouter les event listeners aux dropdowns de maturité
    function addMaturityEventListeners() {
        const maturitySelects = document.querySelectorAll('.maturity-select');
        maturitySelects.forEach(select => {
            // Supprimer les anciens event listeners pour éviter les doublons
            select.removeEventListener('change', handleMaturityChange);
            // Ajouter le nouvel event listener
            select.addEventListener('change', handleMaturityChange);
        });
    }
    
    // Fonction pour gérer le changement de maturité
    function handleMaturityChange() {
        const ticker = this.dataset.ticker;
        const maturity = this.value;
        
        if (maturity) {
            // Ajouter la maturité au ticker actuel
            addMaturityToTicker(ticker, maturity);
            
            // Appliquer automatiquement cette maturité à tous les autres tickers si elle est disponible
            applyMaturityToAllTickers(maturity, ticker);
            
            this.value = ''; // Reset le select
        }
    }
    
    // Fonction pour appliquer une maturité à tous les tickers disponibles
    function applyMaturityToAllTickers(maturity, excludeTicker) {
        const allMaturitySelects = document.querySelectorAll('.maturity-select');
        let appliedCount = 0;
        
        allMaturitySelects.forEach(select => {
            const ticker = select.dataset.ticker;
            
            // Ignorer le ticker qui a déclenché la sélection
            if (ticker === excludeTicker) return;
            
            // Vérifier si cette maturité est disponible pour ce ticker
            const option = select.querySelector(`option[value="${maturity}"]`);
            if (option) {
                // Vérifier si la maturité n'est pas déjà sélectionnée pour ce ticker
                const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
                if (combinationsDisplay) {
                    const existingChip = combinationsDisplay.querySelector(`[data-maturity="${maturity}"]`);
                    if (!existingChip) {
                        addMaturityToTicker(ticker, maturity);
                        appliedCount++;
                    }
                }
            }
        });
        
        if (appliedCount > 0) {
            showNotification(`Maturité ${maturity} jours appliquée à ${appliedCount} autre(s) ticker(s)`, 'success');
        }
    }
    
    // Fonction pour ajouter une maturité à un ticker
    function addMaturityToTicker(ticker, maturity) {
        const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
        if (!combinationsDisplay) return;
        
        // Trouver la maturité correspondante dans les données chargées
        const maturities = tickerMaturities[ticker];
        if (!maturities) {
            console.error(`❌ Maturités non trouvées pour ${ticker}`);
            return;
        }
        
        const maturityData = maturities.find(m => m.days.toString() === maturity.toString());
        if (!maturityData) {
            console.error(`❌ Maturité ${maturity} non trouvée pour ${ticker}`);
            return;
        }
        
        // Vérifier si la maturité existe déjà
        const existingChip = combinationsDisplay.querySelector(`[data-maturity="${maturity}"]`);
        if (existingChip) {
            showNotification('Cette maturité est déjà sélectionnée pour ce ticker.', 'warning');
            return;
        }
        
        // Supprimer le message "No maturity selected yet"
        const emptyMessage = combinationsDisplay.querySelector('.empty-tickers');
        if (emptyMessage) {
            emptyMessage.remove();
        }
        
        // Créer le chip de maturité avec les vraies données
        const chip = document.createElement('div');
        chip.className = 'ticker-chip';
        chip.dataset.maturity = maturity;
        chip.innerHTML = `
            <span class="ticker-chip-text">${maturityData.display}</span>
            <button class="ticker-chip-remove" onclick="removeMaturityFromTicker('${ticker}', '${maturity}')">
                <i data-lucide="x"></i>
            </button>
        `;
        combinationsDisplay.appendChild(chip);
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
        
        showNotification(`${ticker} - ${maturityData.display} ajouté`, 'success');
        
        // Mettre à jour l'état du bouton Generate
        updateGenerateButtonState();
    }
    
    // Fonction pour supprimer une maturité d'un ticker
    window.removeMaturityFromTicker = function(ticker, maturity) {
        const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
        if (!combinationsDisplay) return;
        
        const chip = combinationsDisplay.querySelector(`[data-maturity="${maturity}"]`);
        if (chip) {
            chip.remove();
        }
        
        // Si plus de maturités, afficher le message vide
        if (combinationsDisplay.children.length === 0) {
            combinationsDisplay.innerHTML = `
                <div class="empty-tickers">
                    <i data-lucide="layers" class="empty-icon"></i>
                    <span>No maturity selected yet</span>
                </div>
            `;
        }
        
        showNotification(`Maturité ${maturity} jours retirée pour ${ticker}`, 'info');
        
        // Mettre à jour l'état du bouton Generate
        updateGenerateButtonState();
    }
    
    // Fonction pour mettre à jour l'état du bouton Generate
    function updateGenerateButtonState() {
        const generateBtn = document.getElementById('smile-compare-btn');
        const clearBtn = document.getElementById('clear-all-btn');
        
        if (!generateBtn || !clearBtn) return;
        
        // Vérifier s'il y a des tickers sélectionnés
        const hasTickers = smileComparisonTickers.length > 0;
        
        // Vérifier que TOUS les tickers ont au moins une maturité sélectionnée
        let allTickersHaveMaturities = true;
        
        if (hasTickers) {
            for (const ticker of smileComparisonTickers) {
                const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
                if (combinationsDisplay) {
                    const maturityChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                    if (maturityChips.length === 0) {
                        allTickersHaveMaturities = false;
                        break;
                    }
                } else {
                    allTickersHaveMaturities = false;
                    break;
                }
            }
        } else {
            allTickersHaveMaturities = false;
        }
        
        // Activer/désactiver les boutons
        const shouldEnable = hasTickers && allTickersHaveMaturities;
        
        generateBtn.disabled = !shouldEnable;
        clearBtn.disabled = !hasTickers;
        
    }
    
    // Initialiser les tickers au chargement
    renderSelectedTickers();
    
    // Les tickers sont maintenant chargés globalement au démarrage de la page
    // loadAvailableTickers(); // Remplacé par loadGlobalAvailableTickers()
    
    // Mettre à jour l'état initial des boutons
    updateGenerateButtonState();
    
    // Fonction pour afficher les notifications
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <div class="notification-icon">
                    <i data-lucide="${type === 'error' ? 'alert-circle' : 'info'}"></i>
                </div>
                <div class="notification-message">${message}</div>
                <button class="notification-close">
                    <i data-lucide="x"></i>
                </button>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Initialiser les icônes
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Auto-remove après 5 secondes
        setTimeout(() => {
            notification.remove();
        }, 5000);
        
        // Fermer manuellement
        notification.querySelector('.notification-close').addEventListener('click', () => {
            notification.remove();
        });
    }
    
         // Fonction pour mettre à jour la section debug
     function updateDebugSection(data, symbol) {
         // Mettre à jour le résumé
         document.getElementById('debug-symbol').textContent = symbol;
         document.getElementById('debug-spot-price').textContent = data.spot_price ? `$${data.spot_price.toFixed(2)}` : 'N/A';
         // Nettoyer le texte de la source pour supprimer "(Données Réelles)"
         let sourceText = data.data_source || 'N/A';
         sourceText = sourceText.replace(/\s*\(Données Réelles\)\s*/g, '');
         document.getElementById('debug-source').textContent = sourceText;
         
         // Calculer le nombre total d'options si pas fourni
         let totalOptions = data.total_options;
         let callsCount = data.calls_count;
         let putsCount = data.puts_count;
         
         if (!totalOptions && data.raw_options && data.raw_options.length > 0) {
             totalOptions = data.raw_options.length;
             callsCount = data.raw_options.filter(opt => opt.type === 'call').length;
             putsCount = data.raw_options.filter(opt => opt.type === 'put').length;
         } else if (!totalOptions && data.iv && data.iv.length > 0) {
             // Estimer à partir de la matrice IV
             const nonNullValues = data.iv.flat().filter(v => v !== null && v !== undefined && v > 0).length;
             totalOptions = nonNullValues;
             callsCount = Math.floor(nonNullValues / 2); // Estimation
             putsCount = Math.floor(nonNullValues / 2); // Estimation
         }
         
         document.getElementById('debug-total-options').textContent = totalOptions || 0;
         document.getElementById('debug-calls-count').textContent = callsCount || 0;
         document.getElementById('debug-puts-count').textContent = putsCount || 0;
         document.getElementById('debug-maturities-count').textContent = data.maturities ? data.maturities.length : 0;
         document.getElementById('debug-strikes-count').textContent = data.strikes ? data.strikes.length : 0;
         
         if (data.statistics) {
             document.getElementById('debug-iv-min').textContent = `${(data.statistics.min_iv * 100).toFixed(2)}%`;
             document.getElementById('debug-iv-max').textContent = `${(data.statistics.max_iv * 100).toFixed(2)}%`;
             document.getElementById('debug-iv-avg').textContent = `${(data.statistics.mean_iv * 100).toFixed(2)}%`;
         } else {
             // Calculer les statistiques à partir des données IV si pas disponibles
             if (data.iv && data.iv.length > 0) {
                 const ivs = data.iv.flat().filter(v => v !== null && !isNaN(v));
                 if (ivs.length > 0) {
                     const minIV = Math.min(...ivs);
                     const maxIV = Math.max(...ivs);
                     const avgIV = ivs.reduce((a, b) => a + b, 0) / ivs.length;
                     
                     document.getElementById('debug-iv-min').textContent = `${(minIV * 100).toFixed(2)}%`;
                     document.getElementById('debug-iv-max').textContent = `${(maxIV * 100).toFixed(2)}%`;
                     document.getElementById('debug-iv-avg').textContent = `${(avgIV * 100).toFixed(2)}%`;
                 }
             }
         }
         
         // Mettre à jour le JSON brut
         document.getElementById('debug-raw-json').textContent = JSON.stringify(data, null, 2);
         
         // Mettre à jour le tableau des options
         updateOptionsTable(data.raw_options || []);
         
        // Mettre à jour la matrice IV
        updateIVMatrix(data.iv, data.strikes, data.maturities);
        
        // Mettre à jour le tableau des détails IV
        updateIVDetailsTable(data.raw_options || []);
    }
     
     // Fonction pour mettre à jour le tableau des options
     function updateOptionsTable(options) {
         const tbody = document.getElementById('debug-options-tbody');
         tbody.innerHTML = '';
         
         // Limiter à 100 options pour les performances
         const limitedOptions = options.slice(0, 100);
         
         limitedOptions.forEach(option => {
             const row = document.createElement('tr');
             row.innerHTML = `
                 <td>${option.contractSymbol || 'N/A'}</td>
                 <td>${option.type || 'N/A'}</td>
                 <td>$${option.strike || 0}</td>
                 <td>$${option.lastPrice || 0}</td>
                 <td>${((option.impliedVolatility || 0) * 100).toFixed(2)}%</td>
                 <td>${option.expiration_date || 'N/A'}</td>
             `;
             tbody.appendChild(row);
         });
         
         if (options.length > 100) {
             const row = document.createElement('tr');
             row.innerHTML = `<td colspan="6" style="text-align: center; color: #9ca3af;">... et ${options.length - 100} autres options</td>`;
             tbody.appendChild(row);
         }
     }
     
     // Fonction pour mettre à jour la matrice IV
     function updateIVMatrix(ivMatrix, strikes, maturities) {
         const container = document.getElementById('debug-iv-matrix');
         
         if (!ivMatrix || !strikes || !maturities) {
             container.innerHTML = '<p style="color: #9ca3af;">Aucune donnée de matrice disponible</p>';
             return;
         }
         
         let matrixHTML = '<div style="font-family: monospace; white-space: pre;">';
         
         // En-tête avec les strikes
         matrixHTML += 'Maturité/Strike';
         strikes.forEach(strike => {
             matrixHTML += `\t$${strike}`;
         });
         matrixHTML += '\n';
         
         // Lignes avec les maturités et IV
         maturities.forEach((maturity, i) => {
             matrixHTML += `${maturity.toFixed(2)}a`;
             ivMatrix[i].forEach(iv => {
                 if (iv !== null && iv !== undefined) {
                     matrixHTML += `\t${(iv * 100).toFixed(1)}%`;
                 } else {
                     matrixHTML += '\t-';
                 }
             });
             matrixHTML += '\n';
         });
         
        matrixHTML += '</div>';
        container.innerHTML = matrixHTML;
    }
    
    // Fonction pour mettre à jour le tableau des détails IV
    function updateIVDetailsTable(options) {
        const tbody = document.getElementById('iv-details-tbody');
        tbody.innerHTML = '';
        
        if (!options || options.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #9ca3af;">Aucune donnée disponible</td></tr>';
            return;
        }
        
        // Trier les options par maturité puis par strike
        const sortedOptions = options.sort((a, b) => {
            if (a.expiration_date !== b.expiration_date) {
                return a.expiration_date.localeCompare(b.expiration_date);
            }
            return a.strike - b.strike;
        });
        
        // Limiter à 200 options pour les performances
        const limitedOptions = sortedOptions.slice(0, 200);
        
        limitedOptions.forEach(option => {
            const row = document.createElement('tr');
            const iv = option.impliedVolatility || 0;
            const ivPercent = iv * 100;
            
            // Colorer la ligne selon le type d'option
            if (option.type === 'call') {
                row.style.backgroundColor = '#f0f9ff'; // Bleu clair pour les calls
            } else {
                row.style.backgroundColor = '#fef2f2'; // Rouge clair pour les puts
            }
            
            row.innerHTML = `
                <td>${option.expiration_date || 'N/A'}</td>
                <td>$${(option.strike || 0).toFixed(2)}</td>
                <td><span class="option-type ${option.type}">${(option.type || 'N/A').toUpperCase()}</span></td>
                <td>$${(option.lastPrice || 0).toFixed(2)}</td>
                <td>${iv.toFixed(4)}</td>
                <td><span class="iv-percent ${ivPercent > 50 ? 'high' : ivPercent > 30 ? 'medium' : 'low'}">${ivPercent.toFixed(2)}%</span></td>
            `;
            tbody.appendChild(row);
        });
        
        if (options.length > 200) {
            const row = document.createElement('tr');
            row.innerHTML = `<td colspan="6" style="text-align: center; color: #9ca3af; font-style: italic;">... et ${options.length - 200} autres options</td>`;
            tbody.appendChild(row);
        }
    }
    
    // Gestion des onglets debug
     document.addEventListener('click', (e) => {
         if (e.target.classList.contains('debug-tab')) {
             const tabName = e.target.getAttribute('data-tab');
             
             // Retirer la classe active de tous les onglets
             document.querySelectorAll('.debug-tab').forEach(tab => {
                 tab.classList.remove('active');
             });
             
             // Retirer la classe active de tous les panels
             document.querySelectorAll('.debug-panel').forEach(panel => {
                 panel.classList.remove('active');
             });
             
             // Ajouter la classe active à l'onglet cliqué
             e.target.classList.add('active');
             
             // Afficher le panel correspondant
             document.getElementById(`${tabName}-panel`).classList.add('active');
         }
     });
     
     // Initialiser les icônes Lucide au chargement
     document.addEventListener('DOMContentLoaded', () => {
         if (window.lucide) {
             lucide.createIcons();
         }
         

     });
     
     // ===== SECTION DONNÉES BRUTES =====
     
     // Gestion des symboles personnalisés pour les données brutes
     const rawSymbolSelect = document.getElementById('raw-symbol-select');
     const rawCustomWrap = document.getElementById('raw-custom-wrap');
     const rawCustomInput = document.getElementById('raw-symbol');
     
     function getCurrentRawSymbol() {
         return (rawSymbolSelect && rawSymbolSelect.value === '__custom__') ? (rawCustomInput && rawCustomInput.value || '').trim() : (rawSymbolSelect ? rawSymbolSelect.value : '');
     }
     
     if (rawSymbolSelect) {
         rawSymbolSelect.addEventListener('change', () => {
             const show = rawSymbolSelect.value === '__custom__';
             if (show) {
                 if (rawCustomWrap) rawCustomWrap.classList.remove('hidden');
                 if (rawCustomInput) rawCustomInput.focus();
             } else {
                 if (rawCustomWrap) rawCustomWrap.classList.add('hidden');
             }
         });
     }
     
     // Fonction pour récupérer les données de toutes les sources
     async function fetchAllSourcesData(symbol, maxExp, span) {
         const sources = [];
         const results = {};
         
         // Déterminer quelles sources sont sélectionnées
         // Utiliser uniquement Tradier
         sources.push('tradier');
         
         if (sources.length === 0) {
             throw new Error('Aucune source sélectionnée');
         }
         
         // Récupérer les données de chaque source
         for (const source of sources) {
             try {
                 const url = `/api/vol-surface-3d-tradier-simple/${encodeURIComponent(symbol)}?span=${span}&_t=${Date.now()}`;
                 const response = await fetch(url);
                 const data = await response.json();
                 
                 results[source] = {
                     success: true,
                     data: data,
                     timestamp: new Date().toISOString()
                 };
             } catch (error) {
                 console.error(`Erreur pour ${source}:`, error);
                 results[source] = {
                     success: false,
                     error: error.message,
                     timestamp: new Date().toISOString()
                 };
             }
         }
         
         return results;
     }
     
     // Fonction pour afficher la vue d'ensemble
     function displayOverview(results, symbol) {
         const container = document.getElementById('overview-content');
         let html = '<div class="overview-cards">';
         
         Object.entries(results).forEach(([source, result]) => {
             const statusClass = result.success ? 'success' : 'error';
             const statusIcon = result.success ? '✓' : '✗';
             const statusText = result.success ? 'Succès' : 'Erreur';
             
             html += `
                 <div class="overview-card ${statusClass}">
                     <div class="card-header">
                         <h5>${source.toUpperCase()}</h5>
                         <span class="status-badge ${statusClass}">${statusIcon} ${statusText}</span>
                     </div>
                     <div class="card-content">
             `;
             
             if (result.success) {
                 const data = result.data;
                 html += `
                     <div class="metric-row">
                         <span class="metric-label">Spot Price:</span>
                         <span class="metric-value">$${data.spot_price ? data.spot_price.toFixed(2) : 'N/A'}</span>
                     </div>
                     <div class="metric-row">
                         <span class="metric-label">Options:</span>
                         <span class="metric-value">${data.total_options || 0}</span>
                     </div>
                     <div class="metric-row">
                         <span class="metric-label">Maturities:</span>
                         <span class="metric-value">${data.maturities ? data.maturities.length : 0}</span>
                     </div>
                     <div class="metric-row">
                         <span class="metric-label">Strikes:</span>
                         <span class="metric-value">${data.strikes ? data.strikes.length : 0}</span>
                     </div>
                     <div class="metric-row">
                         <span class="metric-label">IV Moyenne:</span>
                         <span class="metric-value">${data.statistics ? (data.statistics.avg_iv * 100).toFixed(2) + '%' : 'N/A'}</span>
                     </div>
                 `;
             } else {
                 html += `
                     <div class="error-message">
                         <p>${result.error}</p>
                     </div>
                 `;
             }
             
             html += `
                     </div>
                     <div class="card-footer">
                         <small>${new Date(result.timestamp).toLocaleTimeString('fr-FR')}</small>
                     </div>
                 </div>
             `;
         });
         
         html += '</div>';
         container.innerHTML = html;
     }
     
     // Fonction pour afficher les détails par source
     function displaySourceDetails(results) {
         const container = document.getElementById('source-details-content');
         let html = '';
         
         Object.entries(results).forEach(([source, result]) => {
             html += `
                 <div class="source-detail-card">
                     <div class="detail-header">
                         <h5>${source.toUpperCase()} - Détails complets</h5>
                         <span class="status-badge ${result.success ? 'success' : 'error'}">
                             ${result.success ? '✓ Succès' : '✗ Erreur'}
                         </span>
                     </div>
                     <div class="detail-content">
             `;
             
             if (result.success) {
                 const data = result.data;
                 html += `
                     <div class="detail-section">
                         <h6>Informations générales</h6>
                         <div class="detail-grid">
                             <div class="detail-item">
                                 <span class="detail-label">Spot Price:</span>
                                 <span class="detail-value">$${data.spot_price ? data.spot_price.toFixed(2) : 'N/A'}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">Source:</span>
                                 <span class="detail-value">${data.data_source || 'N/A'}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">Total Options:</span>
                                 <span class="detail-value">${data.total_options || 0}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">Calls:</span>
                                 <span class="detail-value">${data.calls_count || 0}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">Puts:</span>
                                 <span class="detail-value">${data.puts_count || 0}</span>
                             </div>
                         </div>
                     </div>
                     
                     <div class="detail-section">
                         <h6>Statistiques IV</h6>
                         <div class="detail-grid">
                             <div class="detail-item">
                                 <span class="detail-label">IV Min:</span>
                                 <span class="detail-value">${data.statistics ? (data.statistics.min_iv * 100).toFixed(2) + '%' : 'N/A'}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">IV Max:</span>
                                 <span class="detail-value">${data.statistics ? (data.statistics.max_iv * 100).toFixed(2) + '%' : 'N/A'}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">IV Moyenne:</span>
                                 <span class="detail-value">${data.statistics ? (data.statistics.avg_iv * 100).toFixed(2) + '%' : 'N/A'}</span>
                             </div>
                             <div class="detail-item">
                                 <span class="detail-label">IV Écart-type:</span>
                                 <span class="detail-value">${data.statistics ? (data.statistics.std_iv * 100).toFixed(2) + '%' : 'N/A'}</span>
                             </div>
                         </div>
                     </div>
                     
                     <div class="detail-section">
                         <h6>Available Maturities</h6>
                         <div class="maturities-list">
                             ${data.maturities ? data.maturities.map(m => `${m.toFixed(2)}a`).join(', ') : 'Aucune'}
                         </div>
                     </div>
                     
                     <div class="detail-section">
                         <h6>Strikes disponibles</h6>
                         <div class="strikes-list">
                             ${data.strikes ? data.strikes.slice(0, 10).map(s => `$${s}`).join(', ') + (data.strikes.length > 10 ? '...' : '') : 'Aucun'}
                         </div>
                     </div>
                 `;
             } else {
                 html += `
                     <div class="error-details">
                         <h6>Erreur détaillée</h6>
                         <p>${result.error}</p>
                         <p><strong>Timestamp:</strong> ${new Date(result.timestamp).toLocaleString('fr-FR')}</p>
                     </div>
                 `;
             }
             
             html += `
                     </div>
                 </div>
             `;
         });
         
         container.innerHTML = html;
     }
     
     // Fonction pour afficher la comparaison directe
     function displayComparison(results) {
         const container = document.getElementById('comparison-chart');
         
         // Filtrer les sources avec succès
         const successfulSources = Object.entries(results).filter(([source, result]) => result.success);
         
         if (successfulSources.length < 2) {
             container.innerHTML = '<div class="no-comparison"><p>Au moins 2 sources avec succès sont nécessaires pour la comparaison</p></div>';
             return;
         }
         
         // Créer un graphique de comparaison simple
         const traces = [];
         const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
         
         successfulSources.forEach(([source, result], index) => {
             const data = result.data;
             if (data.iv && data.strikes && data.maturities) {
                 // Prendre la première maturité pour la comparaison
                 const firstMaturityIndex = 0;
                 const ivs = data.iv[firstMaturityIndex];
                 const strikes = data.strikes;
                 
                 // Filtrer les valeurs non-null
                 const validData = strikes.map((strike, i) => ({
                     strike: strike,
                     iv: ivs[i]
                 })).filter(item => item.iv !== null && !isNaN(item.iv));
                 
                 if (validData.length > 0) {
                     traces.push({
                         x: validData.map(d => d.strike),
                         y: validData.map(d => d.iv * 100), // Convertir en pourcentage
                         type: 'scatter',
                         mode: 'lines+markers',
                         name: `${source.toUpperCase()} (${data.maturities[firstMaturityIndex].toFixed(2)}a)`,
                         line: { color: colors[index % colors.length] },
                         marker: { size: 4 }
                     });
                 }
             }
         });
         
         if (traces.length > 0) {
             const layout = {
                 title: 'Comparison of Implied Volatility Curves',
                 xaxis: { 
                     title: 'Strike (% du Spot)'
                 },
                                    yaxis: { title: 'Implied Volatility (%)' },
                 paper_bgcolor: '#1a1a1a',
                 plot_bgcolor: '#1a1a1a',
                 font: { color: '#ffffff' },
                 legend: { 
                     x: 1, 
                     y: 1,
                     xanchor: 'right',
                     yanchor: 'top',
                     bgcolor: 'rgba(0,0,0,0.7)',
                     bordercolor: 'rgba(55, 65, 81, 0.5)',
                     borderwidth: 1
                 }
             };
             
             Plotly.newPlot(container, traces, layout, { responsive: true });
         } else {
             container.innerHTML = '<div class="no-data"><p>Aucune donnée valide pour la comparaison</p></div>';
         }
     }
     
     // Fonction pour afficher les données brutes
     function displayRawData(results) {
         const container = document.getElementById('raw-data-content');
         let html = '<div class="raw-data-tabs">';
         
         Object.entries(results).forEach(([source, result]) => {
             html += `
                 <div class="raw-data-section">
                     <h5>${source.toUpperCase()}</h5>
                     <div class="raw-json-viewer">
                         <pre class="json-content">${JSON.stringify(result, null, 2)}</pre>
                     </div>
                 </div>
             `;
         });
         
         html += '</div>';
         container.innerHTML = html;
     }
     
         // Gestion du bouton de comparaison
    const rawCompareBtn = document.getElementById('raw-compare-btn');
    if (rawCompareBtn) {
        rawCompareBtn.addEventListener('click', async () => {
         try {
             const symbol = getCurrentRawSymbol();
             if (!symbol) {
                 showNotification('Veuillez choisir un symbole.', 'error');
                 return;
             }
             
             const maxExp = 3; // Valeur par défaut
             const span = 0.5; // Valeur par défaut (50%)
             
             // Vérifier qu'au moins une source est sélectionnée
             const sources = ['Tradier']; // Utiliser uniquement Tradier
             
             if (sources.length === 0) {
                 showNotification('Veuillez sélectionner au moins une source.', 'error');
                 return;
             }
             
             
             // Afficher le loader
             const resultsContainer = document.getElementById('raw-results');
             resultsContainer.classList.remove('hidden');
             resultsContainer.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><p>Comparaison des sources en cours...</p></div>';
             
             // Récupérer les données
             const results = await fetchAllSourcesData(symbol, maxExp, span);
             
             // Afficher les résultats
             resultsContainer.innerHTML = `
                 <div class="results-header">
                     <h4>Résultats de la comparaison - ${symbol}</h4>
                     <div class="results-summary" id="raw-summary">
                         <span>Sources testées: ${Object.keys(results).join(', ')}</span>
                         <span>Succès: ${Object.values(results).filter(r => r.success).length}/${Object.keys(results).length}</span>
                     </div>
                 </div>
                 
                 <div class="results-tabs">
                     <button class="results-tab active" data-tab="overview">Vue d'ensemble</button>
                     <button class="results-tab" data-tab="details">Détails par source</button>
                     <button class="results-tab" data-tab="comparison">Comparaison directe</button>
                     <button class="results-tab" data-tab="raw-data">Données brutes</button>
                 </div>
                 
                 <div class="results-panels">
                     <div id="overview-panel" class="results-panel active">
                         <div class="overview-grid" id="overview-content"></div>
                     </div>
                     <div id="details-panel" class="results-panel">
                         <div class="source-details" id="source-details-content"></div>
                     </div>
                     <div id="comparison-panel" class="results-panel">
                         <div class="comparison-chart" id="comparison-chart"></div>
                     </div>
                     <div id="raw-data-panel" class="results-panel">
                         <div class="raw-data-content" id="raw-data-content"></div>
                     </div>
                 </div>
             `;
             
             // Afficher le contenu des onglets
             displayOverview(results, symbol);
             displaySourceDetails(results);
             displayComparison(results);
             displayRawData(results);
             
             // Gestion des onglets de résultats
             document.querySelectorAll('.results-tab').forEach(tab => {
                 tab.addEventListener('click', (e) => {
                     const tabName = e.target.getAttribute('data-tab');
                     
                     // Retirer la classe active de tous les onglets et panels
                     document.querySelectorAll('.results-tab').forEach(t => t.classList.remove('active'));
                     document.querySelectorAll('.results-panel').forEach(p => p.classList.remove('active'));
                     
                     // Ajouter la classe active
                     e.target.classList.add('active');
                     document.getElementById(`${tabName}-panel`).classList.add('active');
                 });
             });
             
             showNotification(`Comparaison terminée pour ${symbol}`, 'success');
             
         } catch (error) {
             console.error('Erreur lors de la comparaison:', error);
             showNotification(`Erreur: ${error.message}`, 'error');
         }
     });
     }
     
         // Gestion du bouton d'export
    const rawExportBtn = document.getElementById('raw-export-btn');
    if (rawExportBtn) {
        rawExportBtn.addEventListener('click', () => {
         const resultsContainer = document.getElementById('raw-results');
         if (resultsContainer.classList.contains('hidden')) {
             showNotification('Aucune donnée à exporter. Lancez d\'abord une comparaison.', 'error');
             return;
         }
         
         // Récupérer les données actuelles (simulation)
         const exportData = {
             timestamp: new Date().toISOString(),
             symbol: getCurrentRawSymbol(),
             sources: ['tradier'], // Sources disponibles pour la surface de volatilité
             note: 'Données exportées depuis l\'interface de comparaison'
         };
         
         // Créer et télécharger le fichier
         const dataStr = JSON.stringify(exportData, null, 2);
         const dataBlob = new Blob([dataStr], { type: 'application/json' });
         const url = URL.createObjectURL(dataBlob);
         
         const link = document.createElement('a');
         link.href = url;
         link.download = `comparison_${getCurrentRawSymbol()}_${new Date().toISOString().split('T')[0]}.json`;
         document.body.appendChild(link);
         link.click();
         document.body.removeChild(link);
         URL.revokeObjectURL(url);
         
         showNotification('Données exportées avec succès', 'success');
     });
     }
     
    // Gestion des tickers pour la comparaison des sourires (suite)
    
    // Gestion du select pour ajouter des tickers
    // Event listener pour le dropdown des tickers
    const smileTickerSelect = document.getElementById('smile-ticker-select');
    
    if (smileTickerSelect) {
        smileTickerSelect.addEventListener('change', () => {
            const selectedValue = smileTickerSelect.value;
            
            if (selectedValue && selectedValue !== '') {
                addTicker(selectedValue);
                // Reset du select
                smileTickerSelect.value = '';
            }
        });
    }
    

    
    // Fonction pour récupérer les données du smile via Tradier
    async function fetchVolatilitySmile(symbol, maturity, span) {
        const url = `/api/volatility-smile-tradier/${encodeURIComponent(symbol)}?maturity=${maturity}&span=${span}&_t=${Date.now()}`;
        
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            return data;
        } catch (error) {
            console.error('Error fetching volatility smile from Tradier:', error);
            throw error;
        }
    }
    
    // Fonction pour créer le graphique de comparaison des sourires
    function createSmileComparisonChart(allData, maturities) {
        const chartDiv = document.getElementById('smile-chart');
        
        
        if (!allData || allData.length === 0) {
            chartDiv.innerHTML = '<div class="chart-error"><div class="chart-error-icon"><i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i></div><div class="chart-error-title">Données insuffisantes</div><div class="chart-error-message">Aucune donnée de volatilité implicite disponible pour créer le graphique</div></div>';
            return;
        }
        
        // Préparer les traces pour Plotly
        const traces = [];
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
        
        allData.forEach((data, index) => {
            const color = colors[index % colors.length];
            const symbol = data.symbol;
            const maturity = data.selectedMaturity || data.maturity_days || 30;
            const spotPrice = data.spot_price || 100;
            
            // Vérifier si nous avons des données de smile de Tradier
            if (data.smile_data && data.smile_data.length > 0) {
                // Format Tradier - données combinées calls/puts
                const strikes = data.smile_data.map(item => item.strike);
                const moneyness = data.smile_data.map(item => item.moneyness);
                
                // Vérifier si nous avons des volatilités implicites
                const hasIV = data.smile_data.some(item => item.implied_volatility !== null && item.implied_volatility !== undefined);
                
                if (hasIV) {
                    // Afficher le smile de volatilité implicite
                    const ivs = data.smile_data.map(item => item.implied_volatility || 0);
                    
                    traces.push({
                        x: moneyness.map(m => m * 100), // Convertir moneyness en pourcentage du spot
                        y: ivs.map(iv => iv * 100), // Convertir en pourcentage
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: `${symbol} - ${maturity} days`,
                        line: { color: color, width: 1 },
                        marker: { size: 3, color: color },
                        hovertemplate: 
                            `<b>${symbol}</b><br>` +
                            '<b>Strike:</b> $%{customdata}<br>' +
                            '<b>Moneyness:</b> %{x:.1f}%<br>' +
                            '<b>IV:</b> %{y:.2f}%<br>' +
                            '<extra></extra>',
                        customdata: strikes
                    });
                } else {
                    // Afficher les prix des options à la place
                    const prices = data.smile_data.map(item => item.option_price || 0);
                    
                    traces.push({
                        x: moneyness.map(m => m * 100), // Convertir moneyness en pourcentage du spot
                        y: prices, // Prix des options
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: `${symbol} - ${maturity} days (Prices)`,
                        line: { color: color, width: 1 },
                        marker: { size: 3, color: color },
                        hovertemplate: 
                            `<b>${symbol}</b><br>` +
                            '<b>Strike:</b> $%{customdata}<br>' +
                            '<b>Moneyness:</b> %{x:.1f}%<br>' +
                            '<b>IV:</b> %{y:.2f}%<br>' +
                            '<extra></extra>',
                        customdata: strikes
                    });
                }
                
                // Ligne verticale pour le prix spot (moneyness = 1.0 = 100%)
                let maxValue;
                if (hasIV) {
                    const ivs = data.smile_data.map(item => item.implied_volatility || 0);
                    maxValue = Math.max(...ivs.map(iv => iv * 100));
                } else {
                    const prices = data.smile_data.map(item => item.option_price || 0);
                    maxValue = Math.max(...prices);
                }
                
                traces.push({
                    x: [100, 100], // Prix spot = 100% du spot
                    y: [0, maxValue * 1.1],
                    type: 'scatter',
                    mode: 'lines',
                    name: `${symbol} - Spot Price`,
                    line: { color: color, width: 1, dash: 'dot' },
                    showlegend: false,
                    hovertemplate: 
                        `<b>${symbol} - Spot Price</b><br>` +
                        '<b>Price:</b> 100% of spot<br>' +
                        '<extra></extra>'
                });
            } else {
                // Format legacy - séparer calls et puts
                // Trace pour les calls
                if (data.calls_iv && data.calls_iv.length > 0) {
                    traces.push({
                        x: data.calls_strikes, // Keep strikes in dollars
                        y: data.calls_iv.map(iv => iv * 100), // Convertir en pourcentage
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: `${symbol} - Calls`,
                        line: { color: color, width: 1 },
                        marker: { size: 3, color: color },
                        hovertemplate: 
                        `<b>${symbol} - Spot Price</b><br>` +
                        '<b>Price:</b> 100% of spot<br>' +
                        '<extra></extra>'
                    });
                }
                
                // Trace pour les puts
                if (data.puts_iv && data.puts_iv.length > 0) {
                    traces.push({
                        x: data.puts_strikes, // Keep strikes in dollars
                        y: data.puts_iv.map(iv => iv * 100), // Convertir en pourcentage
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: `${symbol} - Puts`,
                        line: { color: color, width: 1, dash: 'dash' },
                        marker: { size: 3, color: color, symbol: 'diamond' },
                        hovertemplate: 
                        `<b>${symbol} - Spot Price</b><br>` +
                        '<b>Price:</b> 100% of spot<br>' +
                        '<extra></extra>'
                    });
                }
                
                // Ligne verticale pour le prix spot de chaque symbole (100%)
                if (data.spot_price > 0) {
                    const maxIV = Math.max(
                        ...(data.calls_iv || []).map(iv => iv * 100),
                        ...(data.puts_iv || []).map(iv => iv * 100)
                    );
                    
                    traces.push({
                        x: [100, 100], // Prix spot = 100% du spot
                        y: [-15, maxIV * 1.1], // Commencer bien en dessous de 0 pour passer sous le label
                        type: 'scatter',
                        mode: 'lines',
                        name: `${symbol} - Spot Price`,
                        line: { color: color, width: 1, dash: 'dot' },
                        showlegend: false,
                        hovertemplate: 
                        `<b>${symbol} - Spot Price</b><br>` +
                        '<b>Price:</b> 100% of spot<br>' +
                        '<extra></extra>'
                    });
                }
            }
        });
        
        // Déterminer le type de graphique (IV ou prix)
        const hasAnyIV = allData.some(data => 
            data.smile_data && data.smile_data.some(item => 
                item.implied_volatility !== null && item.implied_volatility !== undefined
            )
        );
        
        // Créer le titre avec toutes les maturités
        const maturityText = maturities.length === 1 ? 
            `${maturities[0]} days` : 
            `${maturities.sort((a, b) => a - b).join(', ')} days`;
        
        const chartTitle = hasAnyIV ? 
            `Comparison of Volatility Smiles (${maturityText})` : 
            `Comparison of Option Prices (${maturityText})`;
        
        const yAxisTitle = hasAnyIV ? 'Implied Volatility (%)' : 'Option Price ($)';
        
        // Mettre à jour le titre dans la div HTML
        const titleElement = document.getElementById('smile-chart-title');
        const subtitleElement = document.getElementById('smile-chart-subtitle');
        if (titleElement) {
            titleElement.innerHTML = `<i data-lucide="trending-up" class="volatility-3d-chart-icon"></i>${chartTitle}`;
        }
        if (subtitleElement) {
            subtitleElement.textContent = hasAnyIV ? 
                'Compare implied volatility smiles between different stocks for a specific maturity' :
                'Compare option prices between different stocks for a specific maturity';
        }
        
        // Réinitialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Gérer le toggle de la légende
        const legendToggleBtn = document.getElementById('legend-toggle-btn');
        let legendVisible = true;
        
        if (legendToggleBtn) {
            legendToggleBtn.addEventListener('click', function() {
                legendVisible = !legendVisible;
                
                // Mettre à jour l'icône et le texte
                const icon = legendToggleBtn.querySelector('.legend-toggle-icon');
                const text = legendToggleBtn.querySelector('.legend-toggle-text');
                
                if (legendVisible) {
                    icon.setAttribute('data-lucide', 'eye');
                    text.textContent = 'Legend';
                    legendToggleBtn.title = 'Hide Legend';
                } else {
                    icon.setAttribute('data-lucide', 'eye-off');
                    text.textContent = 'Show';
                    legendToggleBtn.title = 'Show Legend';
                }
                
                // Réinitialiser l'icône Lucide
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                // Mettre à jour la légende dans le graphique
                if (chartDiv && chartDiv.data) {
                    Plotly.relayout(chartDiv, {
                        'showlegend': legendVisible
                    });
                }
            });
        }
        
        // Fonction pour obtenir les tailles responsive
        function getResponsiveSizes() {
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            const isTinyMobile = window.innerWidth <= 360;
            const isTablet = window.innerWidth <= 1024 && window.innerWidth > 768;
            const isDesktop = window.innerWidth > 1024;
            
            let titleSize, axisTitleSize, tickSize, legendSize, legendPosition;
            
            if (isTinyMobile) {
                titleSize = 14;
                axisTitleSize = 10;
                tickSize = 8;
                legendSize = 9;
                legendPosition = { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' };
            } else if (isSmallMobile) {
                titleSize = 16;
                axisTitleSize = 11;
                tickSize = 9;
                legendSize = 10;
                legendPosition = { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' };
            } else if (isMobile) {
                titleSize = 18;
                axisTitleSize = 12;
                tickSize = 10;
                legendSize = 11;
                legendPosition = { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' };
            } else if (isTablet) {
                titleSize = 20;
                axisTitleSize = 13;
                tickSize = 11;
                legendSize = 12;
                legendPosition = { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' };
            } else {
                titleSize = 22;
                axisTitleSize = 14;
                tickSize = 12;
                legendSize = 13;
                legendPosition = { x: 0.02, y: 0.98, xanchor: 'left', yanchor: 'top' };
            }
            
            return {
                titleSize,
                axisTitleSize,
                tickSize,
                legendSize,
                legendPosition,
                isMobile,
                isSmallMobile,
                isTinyMobile,
                isTablet,
                isDesktop
            };
        }
        
        const responsiveSizes = getResponsiveSizes();
        
        // Layout avec fond transparent et styles améliorés et responsive (sans titre)
        const layout = {
            // Pas de titre dans le graphique - il est maintenant dans la div HTML
            xaxis: {
                title: 'Strike (% du Spot)',
                gridcolor: 'rgba(55, 65, 81, 0.3)',
                zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                showbackground: false,
                titlefont: { 
                    color: '#ffffff', 
                    size: responsiveSizes.axisTitleSize, 
                    family: 'Segoe UI' 
                },
                tickfont: { 
                    color: '#d1d5db', 
                    size: responsiveSizes.tickSize, 
                    family: 'Segoe UI' 
                },
                showgrid: true,
                zeroline: true
            },
            yaxis: {
                title: yAxisTitle,
                gridcolor: 'rgba(55, 65, 81, 0.3)',
                zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                showbackground: false,
                titlefont: { 
                    color: '#ffffff', 
                    size: responsiveSizes.axisTitleSize, 
                    family: 'Segoe UI' 
                },
                tickfont: { 
                    color: '#d1d5db', 
                    size: responsiveSizes.tickSize, 
                    family: 'Segoe UI' 
                },
                showgrid: true,
                zeroline: true,
                range: [0, null] // Revenir à 0 pour éviter les valeurs négatives
            },
            paper_bgcolor: 'rgba(0,0,0,0)', // Fond transparent
            plot_bgcolor: 'rgba(0,0,0,0)',  // Fond transparent
            font: {
                color: '#ffffff',
                family: 'Segoe UI'
            },
            margin: {
                l: 60,
                r: 40,
                b: 120, // Augmenter la marge du bas pour permettre à la ligne de passer sous le label
                t: 80
            },
            showlegend: true,
            legend: {
                font: { 
                    color: '#ffffff', 
                    size: responsiveSizes.legendSize, 
                    family: 'Segoe UI' 
                },
                bgcolor: 'rgba(0,0,0,0.7)',
                bordercolor: 'rgba(55, 65, 81, 0.5)',
                borderwidth: 1,
                x: responsiveSizes.legendPosition.x,
                y: responsiveSizes.legendPosition.y,
                xanchor: responsiveSizes.legendPosition.xanchor,
                yanchor: responsiveSizes.legendPosition.yanchor
            },
            hovermode: 'x unified',
            hoverlabel: {
                bgcolor: 'rgba(17, 24, 39, 0.95)',
                bordercolor: '#374151',
                font: {
                    color: '#f9fafb',
                    family: 'Arial, sans-serif',
                    size: 12
                }
            }
        };
        
        // Fonction pour ajuster les marges et les tailles selon la taille d'écran
        function adjustSmileMarginsForScreenSize(layout) {
            if (!layout) return;
            const responsiveSizes = getResponsiveSizes();
            if (!responsiveSizes) return;
            
            // S'assurer que layout.margin existe
            if (!layout.margin) {
                layout.margin = {};
            }
            
            // Ajuster les marges pour que la bordure pointillée englobe les labels
            if (responsiveSizes.isTinyMobile) {
                layout.margin.b = 50; // Réduit pour que la bordure englobe le label X
                layout.margin.l = 50; // Réduit pour que la bordure englobe le label Y
                layout.margin.t = 20; // Réduit car pas de titre
                layout.margin.r = 20;
            } else if (responsiveSizes.isSmallMobile) {
                layout.margin.b = 60;
                layout.margin.l = 60;
                layout.margin.t = 25;
                layout.margin.r = 25;
            } else if (responsiveSizes.isMobile) {
                layout.margin.b = 70;
                layout.margin.l = 70;
                layout.margin.t = 30;
                layout.margin.r = 30;
            } else if (responsiveSizes.isTablet) {
                layout.margin.b = 80;
                layout.margin.l = 80;
                layout.margin.t = 35;
                layout.margin.r = 35;
            } else {
                layout.margin.b = 90;
                layout.margin.l = 90;
                layout.margin.t = 40;
                layout.margin.r = 40;
            }
            
            // S'assurer que les axes existent
            if (!layout.xaxis) layout.xaxis = {};
            if (!layout.yaxis) layout.yaxis = {};
            if (!layout.xaxis.titlefont) layout.xaxis.titlefont = {};
            if (!layout.xaxis.tickfont) layout.xaxis.tickfont = {};
            if (!layout.yaxis.titlefont) layout.yaxis.titlefont = {};
            if (!layout.yaxis.tickfont) layout.yaxis.tickfont = {};
            
            // Mettre à jour les tailles de police (pas de titre dans le graphique)
            layout.xaxis.titlefont.size = responsiveSizes.axisTitleSize;
            layout.xaxis.tickfont.size = responsiveSizes.tickSize;
            layout.yaxis.titlefont.size = responsiveSizes.axisTitleSize;
            layout.yaxis.tickfont.size = responsiveSizes.tickSize;
            if (layout.legend && layout.legend.font) {
                layout.legend.font.size = responsiveSizes.legendSize;
            }
            
            // Ajuster la position de la légende pour les petits écrans
            if (layout.legend) {
                // S'assurer que layout.legend.font existe
                if (!layout.legend.font) {
                    layout.legend.font = {};
                }
                if (responsiveSizes.isTinyMobile) {
                    // Légende en bas à droite pour les très petits écrans
                    layout.legend.x = 0.98;
                    layout.legend.y = 0.02;
                    layout.legend.xanchor = 'right';
                    layout.legend.yanchor = 'bottom';
                    layout.legend.bgcolor = 'rgba(0,0,0,0.8)';
                    layout.legend.borderwidth = 1;
                } else if (responsiveSizes.isSmallMobile) {
                    // Légende en bas à droite pour les petits écrans
                    layout.legend.x = 0.98;
                    layout.legend.y = 0.02;
                    layout.legend.xanchor = 'right';
                    layout.legend.yanchor = 'bottom';
                    layout.legend.bgcolor = 'rgba(0,0,0,0.8)';
                    layout.legend.borderwidth = 1;
                } else if (responsiveSizes.isMobile) {
                    // Légende en bas à droite pour les écrans mobiles
                    layout.legend.x = 0.98;
                    layout.legend.y = 0.02;
                    layout.legend.xanchor = 'right';
                    layout.legend.yanchor = 'bottom';
                    layout.legend.bgcolor = 'rgba(0,0,0,0.7)';
                    layout.legend.borderwidth = 1;
                } else {
                    // Légende en haut à gauche pour les grands écrans
                    layout.legend.x = 0.02;
                    layout.legend.y = 0.98;
                    layout.legend.xanchor = 'left';
                    layout.legend.yanchor = 'top';
                    layout.legend.bgcolor = 'rgba(0,0,0,0.7)';
                    layout.legend.borderwidth = 1;
                }
            }
            
            // Optimiser les hoverlabels pour mobile
            if (!layout.hoverlabel) {
                layout.hoverlabel = {};
            }
            if (!layout.hoverlabel.font) {
                layout.hoverlabel.font = {};
            }
            
            if (responsiveSizes.isMobile) {
                layout.hoverlabel.font.size = 10;
                layout.hoverlabel.bgcolor = 'rgba(17, 24, 39, 0.95)';
                layout.hoverlabel.bordercolor = '#374151';
            } else {
                layout.hoverlabel.font.size = 12;
                layout.hoverlabel.bgcolor = 'rgba(17, 24, 39, 0.95)';
                layout.hoverlabel.bordercolor = '#374151';
            }
        }
        
        // Ajuster les marges avant de créer le graphique
        adjustSmileMarginsForScreenSize(layout);
        
        // Configuration Plotly avec optimisations mobile
        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
            displaylogo: false,
            doubleClick: 'reset+autosize',
            toImageButtonOptions: {
                format: 'png',
                filename: `smile_comparison_${maturities.join('_')}d`,
                height: 600,
                width: 800,
                scale: 2
            },
            // Optimisations pour mobile
            scrollZoom: true,
            editable: false,
            staticPlot: false
        };
        
        Plotly.newPlot(chartDiv, traces, layout, config);
        
        // Forcer le redimensionnement après création pour optimiser la responsivité mobile
        setTimeout(() => {
            if (chartDiv && chartDiv.data) {
                adjustSmileMarginsForScreenSize(layout);
                Plotly.relayout(chartDiv, {
                    'margin.b': layout.margin.b,
                    'margin.l': layout.margin.l,
                    'margin.t': layout.margin.t,
                    'margin.r': layout.margin.r,
                    'xaxis.titlefont.size': layout.xaxis.titlefont.size,
                    'xaxis.tickfont.size': layout.xaxis.tickfont.size,
                    'yaxis.titlefont.size': layout.yaxis.titlefont.size,
                    'yaxis.tickfont.size': layout.yaxis.tickfont.size,
                    'legend.font.size': layout.legend && layout.legend.font ? layout.legend.font.size : 12,
                    'legend.x': layout.legend ? layout.legend.x : 0.02,
                    'legend.y': layout.legend ? layout.legend.y : 0.98,
                    'legend.xanchor': layout.legend ? layout.legend.xanchor : 'left',
                    'legend.yanchor': layout.legend ? layout.legend.yanchor : 'top',
                    'legend.bgcolor': layout.legend.bgcolor,
                    'legend.borderwidth': layout.legend.borderwidth,
                    'hoverlabel.font.size': layout.hoverlabel.font.size,
                    'hoverlabel.bgcolor': layout.hoverlabel.bgcolor,
                    'hoverlabel.bordercolor': layout.hoverlabel.bordercolor
                });
                
                // Forcer le redimensionnement du graphique
                Plotly.Plots.resize(chartDiv);
            }
        }, 100);
        
        // Tooltip natif de Plotly activé
        
        // Gestionnaire pour redimensionner le graphique quand la fenêtre change
        let smileResizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(smileResizeTimeout);
            smileResizeTimeout = setTimeout(function() {
                if (chartDiv && chartDiv.data) {
                    adjustSmileMarginsForScreenSize(layout);
                    Plotly.relayout(chartDiv, {
                        'margin.b': layout.margin.b,
                        'margin.l': layout.margin.l,
                        'margin.t': layout.margin.t,
                        'margin.r': layout.margin.r,
                        'xaxis.titlefont.size': layout.xaxis.titlefont.size,
                        'xaxis.tickfont.size': layout.xaxis.tickfont.size,
                        'yaxis.titlefont.size': layout.yaxis.titlefont.size,
                        'yaxis.tickfont.size': layout.yaxis.tickfont.size,
                        'legend.font.size': layout.legend && layout.legend.font ? layout.legend.font.size : 12,
                        'legend.x': layout.legend ? layout.legend.x : 0.02,
                        'legend.y': layout.legend ? layout.legend.y : 0.98,
                        'legend.xanchor': layout.legend ? layout.legend.xanchor : 'left',
                        'legend.yanchor': layout.legend ? layout.legend.yanchor : 'top',
                        'legend.bgcolor': layout.legend.bgcolor,
                        'legend.borderwidth': layout.legend.borderwidth,
                        'hoverlabel.font.size': layout.hoverlabel.font.size,
                        'hoverlabel.bgcolor': layout.hoverlabel.bgcolor,
                        'hoverlabel.bordercolor': layout.hoverlabel.bordercolor
                    });
                }
            }, 250);
        });
    }
    
    // Fonction pour mettre à jour les statistiques de comparaison
    function updateSmileComparisonStatistics(allData) {
        const container = document.getElementById('smile-comparison-stats');
        
        // Toujours vider le conteneur d'abord
        container.innerHTML = '';
        
        if (!allData || allData.length === 0) {
            container.innerHTML = '<p>Aucune donnée disponible</p>';
            return;
        }
        
        let html = '<div class="comparison-stats-grid">';
        
        allData.forEach((data, index) => {
            // Calculer les statistiques à partir des données de smile
            let stats = {};
            
            if (data.smile_data && data.smile_data.length > 0) {
                // Format Tradier
                const ivs = data.smile_data.map(item => item.implied_volatility);
                const callsCount = data.smile_data.reduce((sum, item) => sum + item.calls_count, 0);
                const putsCount = data.smile_data.reduce((sum, item) => sum + item.puts_count, 0);
                
                stats = {
                    total_options: data.total_options || (callsCount + putsCount),
                    calls_count: callsCount,
                    puts_count: putsCount,
                    min_iv: Math.min(...ivs),
                    max_iv: Math.max(...ivs),
                    avg_iv: ivs.reduce((sum, iv) => sum + iv, 0) / ivs.length
                };
            } else if (data.statistics) {
                // Format legacy
                stats = data.statistics;
            } else {
                // Fallback
                stats = {
                    total_options: 0,
                    calls_count: 0,
                    puts_count: 0,
                    min_iv: 0,
                    max_iv: 0,
                    avg_iv: 0
                };
            }
            
            html += `
                <div class="comparison-stat-card">
                    <div class="stat-card-header">
                        <h4>${data.symbol}</h4>
                        <span class="stat-card-price">$${data.spot_price.toFixed(2)}</span>
                    </div>
                    <div class="stat-card-content">
                        <div class="stat-row">
                            <span class="stat-label">Maturity:</span>
                            <span class="stat-value">${data.selectedMaturity || data.maturity_days || 'N/A'} jours</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Options:</span>
                            <span class="stat-value">${stats.total_options} (${stats.calls_count}C/${stats.puts_count}P)</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Min:</span>
                            <span class="stat-value">${(stats.min_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Max:</span>
                            <span class="stat-value">${(stats.max_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Moy:</span>
                            <span class="stat-value">${(stats.avg_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Source:</span>
                            <span class="stat-value">${data.data_source || 'Tradier API'}</span>
                        </div>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
        
        // Afficher la section des statistiques
        document.getElementById('smile-statistics').classList.remove('hidden');
    }
    
    // Gestion du bouton de comparaison des sourires
    const smileCompareBtn = document.getElementById('smile-compare-btn');
    if (smileCompareBtn) {
        smileCompareBtn.addEventListener('click', async () => {
            try {
                if (smileComparisonTickers.length === 0) {
                    showNotification('Veuillez ajouter au moins un ticker.', 'error');
                    return;
                }
                
                // Mettre à jour le statut API
                updateApiStatus('checking');
                
                // Démarrer le chronomètre pour le temps de réponse
                const startTime = performance.now();
                
                // Collecter toutes les maturités sélectionnées
                selectedMaturities.clear();
                smileComparisonTickers.forEach(ticker => {
                    const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
                    if (combinationsDisplay) {
                        const maturityChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                        maturityChips.forEach(chip => {
                            const maturity = chip.dataset.maturity;
                            if (maturity) {
                                selectedMaturities.add(parseInt(maturity));
                            }
                        });
                    }
                });
                
                if (selectedMaturities.size === 0) {
                    showNotification('Veuillez sélectionner au moins une maturité.', 'error');
                    return;
                }
                
                const span = 0.3; // Span par défaut (30% autour du spot)
                
                
                const chartDiv = document.getElementById('smile-chart');
                const placeholder = document.getElementById('smile-chart-placeholder');
                
                if (placeholder) {
                    placeholder.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><div class="loading-text">Comparaison des smiles de volatilité...</div></div>';
                }
                
                // Récupérer les données pour toutes les combinaisons ticker-maturité
                const allData = [];
                const errors = [];
                
                for (const ticker of smileComparisonTickers) {
                    // Vérifier quelles maturités sont sélectionnées pour ce ticker
                    const tickerMaturities = [];
                    const combinationsDisplay = document.querySelector(`.combinations-display[data-ticker="${ticker}"]`);
                    if (combinationsDisplay) {
                        const maturityChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                        maturityChips.forEach(chip => {
                            const maturity = chip.dataset.maturity;
                            if (maturity) {
                                tickerMaturities.push(parseInt(maturity));
                            }
                        });
                    }
                    
                    // Récupérer les données pour chaque maturité de ce ticker
                    for (const maturity of tickerMaturities) {
                        try {
                            const data = await fetchVolatilitySmile(ticker, maturity, span);
                            
                            if (data && !data.error) {
                                // Ajouter la maturité aux données pour l'identifier
                                data.selectedMaturity = maturity;
                                allData.push(data);
                            } else {
                                errors.push(`${ticker} (${maturity}j): ${data.error || 'Erreur inconnue'}`);
                            }
                        } catch (e) {
                            console.error(`Erreur pour ${ticker} (${maturity}j):`, e);
                            errors.push(`${ticker} (${maturity}j): ${e.message}`);
                        }
                    }
                }
                
                // Supprimer le spinner de chargement
                if (placeholder) {
                    placeholder.innerHTML = '';
                }
                
                if (allData.length > 0) {
                    // Créer le graphique de comparaison avec toutes les maturités
                    createSmileComparisonChart(allData, Array.from(selectedMaturities));
                    
                    // Afficher les statistiques
                    document.getElementById('smile-statistics').classList.remove('hidden');
                    updateSmileComparisonStatistics(allData);
                    
                    // Calculer le temps de réponse
                    const smileEndTime = performance.now();
                    const responseTime = Math.round(smileEndTime - startTime);
                    
                    // Mettre à jour le statut API en cas de succès
                    updateApiStatus('connected', responseTime);
                    
                    // Afficher les notifications
                    if (errors.length > 0) {
                        showNotification(`${allData.length} smiles chargés avec succès. ${errors.length} erreurs.`, 'warning');
                    } else {
                        showNotification(`${allData.length} smiles comparés avec succès!`, 'success');
                    }
                    
                } else {
                    // Aucune donnée récupérée
                    let errorMessage = 'Aucune donnée récupérée pour les tickers sélectionnés.';
                    
                    if (errors.length > 0) {
                        errorMessage += '\n\nErreurs:\n' + errors.join('\n');
                    }
                    
                    chartDiv.innerHTML = `
                        <div class="chart-error">
                            <div class="chart-error-icon">
                                <i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i>
                            </div>
                            <div class="chart-error-title">Erreur de comparaison</div>
                            <div class="chart-error-message">${errorMessage}</div>
                            <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(55, 65, 81, 0.5); border-radius: 0.5rem; border: 1px solid #374151;">
                                <h5 style="color: #3b82f6; margin-bottom: 0.75rem;">
                                    <i data-lucide="lightbulb" style="width: 16px; height: 16px; margin-right: 0.5rem;"></i>
                                    Suggestions :
                                </h5>
                                <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: #d1d5db; font-size: 0.875rem;">
                                    <li>Essayez SPY, QQQ ou IWM (ETF avec beaucoup d'options)</li>
                                    <li>Vérifiez que les symboles sont corrects</li>
                                    <li>Essayez une maturité différente (30, 60, 90 jours)</li>
                                    <li>Augmentez l'écart autour du spot (span)</li>
                                </ul>
                            </div>
                        </div>`;
                }
                
            } catch (e) {
                console.error('Erreur lors de la comparaison des smiles:', e);
                updateApiStatus('error');
                const chartDiv = document.getElementById('smile-chart');
                chartDiv.innerHTML = `<div class="chart-error"><div class="chart-error-icon"><i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i></div><div class="chart-error-title">Erreur de connexion</div><div class="chart-error-message">${e.message}</div></div>`;
            }
        });
    }
    
    // Gestion du bouton Clear All
    const clearAllBtn = document.getElementById('clear-all-btn');
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', () => {
            // Vider la liste des tickers
            smileComparisonTickers = [];
            
            // Nettoyer les données en cache et les sélections
            selectedMaturities.clear();
            currentSelections = {};
            
            // Vider le tableau des combinaisons (Volatility Smile uniquement)
            const smileSection = document.querySelector('.volatility-smile-section:not(.term-structure-section)');
            const tbody = smileSection ? smileSection.querySelector('.combinations-table tbody') : null;
            if (tbody) {
                tbody.innerHTML = '';
            }
            
            // Remettre le graphique à l'état initial
            const chartDiv = document.getElementById('smile-chart');
            
            if (chartDiv) {
                // Vider complètement le chartDiv
                chartDiv.innerHTML = '';
                chartDiv.classList.remove('js-plotly-plot');
                
                // Recréer complètement le placeholder
                const newPlaceholder = document.createElement('div');
                newPlaceholder.id = 'smile-chart-placeholder';
                newPlaceholder.className = 'chart-placeholder';
                newPlaceholder.innerHTML = `
                    <div class="placeholder-content">
                        <div class="placeholder-icon">
                            <i data-lucide="bar-chart" style="width: 48px; height: 48px; color: #6b7280;"></i>
                        </div>
                        <h4>Comparison of Smiles</h4>
                        <p>Add tickers and click "Compare Smiles" to display the implied volatility curves</p>
                    </div>
                `;
                
                // Réattacher le placeholder au chartDiv
                chartDiv.appendChild(newPlaceholder);
                
                // Réinitialiser les icônes Lucide
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            
            // Masquer les statistiques et vider leur contenu
            const statisticsDiv = document.getElementById('smile-statistics');
            if (statisticsDiv) {
                statisticsDiv.classList.add('hidden');
            }
            
            // Vider le contenu des statistiques
            updateSmileComparisonStatistics([]);
            
            // Mettre à jour l'affichage des tickers sélectionnés
            renderSelectedTickers();
            
            // Mettre à jour l'état des boutons
            updateGenerateButtonState();
            
            // Mettre à jour les compteurs
            updateTickerCounts();
            
            // Afficher une notification
            showNotification('Toutes les sélections ont été effacées', 'info');
        });
    }
    
    // Tooltip natif de Plotly utilisé - plus de conflits
    
    // ========================================
    // JAVASCRIPT POUR TERM STRUCTURE COMPARISON
    // ========================================
    
    // Variables pour la section Term Structure
    let termStructureTickers = [];
    let termStructureMaturities = {};
    let termStructureAvailableTickers = [];
    
    // Fonction pour charger les strikes d'un ticker pour Term Structure depuis l'API Tradier
    async function loadTermStructureTickerStrikes(ticker) {
        // Vérifier le cache d'abord
        if (termStructureMaturities[ticker]) {
            return termStructureMaturities[ticker];
        }
        
        // Pré-valider le ticker pour éviter les erreurs 404
        const hasOptions = await validateTickerHasOptions(ticker);
        if (!hasOptions) {
            console.log(`ℹ️ ${ticker} pré-validé pour Term Structure: pas d'options disponibles (évite 404)`);
            termStructureMaturities[ticker] = [];
            return [];
        }
        
        try {
            // Récupérer l'union des strikes de plusieurs maturités spécifiques
            const strikesResponse = await fetch(`/api/tradier/strikes-union/${ticker}`);
            
            if (!strikesResponse.ok) {
                if (strikesResponse.status === 404) {
                    // Ticker sans options disponibles (cas rare après pré-validation)
                    console.warn(`⚠️ ${ticker} n'a pas d'options disponibles pour Term Structure (404 inattendu)`);
                    tickersWithoutOptions.add(ticker);
                    tickerValidationCache.set(ticker, false); // Mettre à jour le cache
                    termStructureMaturities[ticker] = [];
                    return [];
                }
                throw new Error(`HTTP ${strikesResponse.status}: ${strikesResponse.statusText}`);
            }
            
            const strikesData = await strikesResponse.json();
            
            if (strikesData && strikesData.success && strikesData.strikes && strikesData.strikes.length > 0) {
                // Utiliser les données déjà formatées côté serveur
                const strikes = strikesData.strikes.map(strikeItem => ({
                    strike: strikeItem.strike,
                    display: strikeItem.display,
                    percentage_display: strikeItem.percentage_display,
                    percentage: strikeItem.percentage,
                    spotPrice: strikesData.spot_price,
                    selectedExpirations: strikesData.selected_expirations
                }));
                
                console.log(`✅ Union des strikes pour ${ticker}: ${strikes.length} strikes uniques`);
                console.log(`📅 Maturités utilisées: ${strikesData.selected_expirations.join(', ')}`);
                
                // Ticker avec options disponibles
                tickersWithOptions.add(ticker);
                termStructureMaturities[ticker] = strikes;
                return strikes;
            } else {
                // Aucune strike trouvée
                console.warn(`⚠️ ${ticker} n'a pas d'options disponibles pour Term Structure`);
                tickersWithoutOptions.add(ticker);
                termStructureMaturities[ticker] = [];
                return [];
            }
        } catch (error) {
            console.error(`❌ Erreur lors du chargement des strikes Term Structure pour ${ticker}:`, error);
            // Marquer comme ticker sans options
            tickersWithoutOptions.add(ticker);
            termStructureMaturities[ticker] = [];
            return [];
        }
    }
    
    // Fonction pour charger les tickers disponibles depuis l'API pour Term Structure
    async function loadTermStructureAvailableTickers() {
        await loadGlobalAvailableTickers();
        synchronizeTickers();
    }
    
    // Fonction pour mettre à jour le dropdown des tickers pour Term Structure
    function updateTermStructureTickerDropdown() {
        const select = document.getElementById('term-structure-ticker-select');
        if (!select) {
            console.error('❌ Élément term-structure-ticker-select non trouvé');
            return;
        }
        
        
        // Vider les options existantes (garder la première option)
        select.innerHTML = '<option value="">Choose a ticker to add...</option>';
        
        // Ajouter les tickers disponibles
        termStructureAvailableTickers.forEach(tickerData => {
            const option = document.createElement('option');
            option.value = tickerData.symbol;
            option.textContent = tickerData.label || tickerData.symbol;
            select.appendChild(option);
        });
        
    }
    
    // Fonction pour rendre les tickers sélectionnés pour Term Structure
    function renderTermStructureSelectedTickers() {
        const container = document.getElementById('term-structure-selected-tickers');
        const countBadge = document.getElementById('term-structure-ticker-count');
        
        if (!container) return;
        
        if (termStructureTickers.length === 0) {
            container.innerHTML = `
                <div class="empty-tickers">
                    <i data-lucide="building-2" class="empty-icon"></i>
                    <span>No tickers selected yet</span>
                </div>
            `;
            if (countBadge) countBadge.textContent = '0';
        } else {
            // Méthode plus robuste pour vider le conteneur
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            termStructureTickers.forEach(ticker => {
                const chip = document.createElement('div');
                chip.className = 'ticker-chip';
                chip.innerHTML = `
                    <span class="ticker-chip-text">${ticker}</span>
                    <button class="ticker-chip-remove" onclick="removeTermStructureTicker('${ticker}')">
                        <i data-lucide="x"></i>
                    </button>
                `;
                container.appendChild(chip);
            });
            if (countBadge) countBadge.textContent = termStructureTickers.length.toString();
        }
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
    }
    
    // Fonction pour ajouter un ticker à Term Structure
    async function addTermStructureTicker(ticker) {
        console.log(`🔍 Tentative d'ajout de ${ticker} à termStructureTickers`);
        console.log(`🔍 Liste actuelle: [${termStructureTickers.join(', ')}]`);
        
        if (!termStructureTickers.includes(ticker)) {
            // Pré-valider le ticker pour éviter les erreurs 404
            console.log(`🔍 Validation de ${ticker} avant ajout Term Structure...`);
            const hasOptions = await validateTickerHasOptions(ticker);
            if (!hasOptions) {
                showNotification(`${ticker} n'a pas d'options disponibles. Ticker ignoré.`, 'warning');
                return;
            }
            
            // Charger les strikes (maintenant sécurisé)
            const strikes = await loadTermStructureTickerStrikes(ticker);
            
            if (strikes.length === 0) {
                showNotification(`${ticker} n'a pas d'options disponibles. Ticker ignoré.`, 'warning');
                return;
            }
            
            termStructureTickers.push(ticker);
            console.log(`✅ ${ticker} ajouté. Nouvelle liste: [${termStructureTickers.join(', ')}]`);
            renderTermStructureSelectedTickers();
            updateTermStructureCombinationsTable();
            updateTickerCounts(); // Mettre à jour les compteurs
            // Ne pas appeler updateTermStructureButtons() ici car le tableau n'est pas encore mis à jour
            // La fonction sera appelée automatiquement dans updateTermStructureCombinationsTable()
            showNotification(`${ticker} ajouté à la liste Term Structure`, 'success');
        } else {
            console.log(`⚠️ ${ticker} déjà présent dans la liste`);
            showNotification('Ce ticker est déjà dans la liste Term Structure.', 'warning');
        }
    }
    
    // Fonction pour supprimer un ticker de Term Structure
    window.removeTermStructureTicker = function(ticker) {
        termStructureTickers = termStructureTickers.filter(t => t !== ticker);
        renderTermStructureSelectedTickers();
        updateTermStructureCombinationsTable();
        updateTickerCounts(); // Mettre à jour les compteurs
        // updateTermStructureButtons() sera appelé automatiquement dans updateTermStructureCombinationsTable()
        showNotification(`${ticker} retiré de la liste Term Structure`, 'info');
    }
    
    // Fonction pour vérifier et mettre à jour l'état des boutons Term Structure
    function updateTermStructureButtons() {
        const generateBtn = document.getElementById('term-structure-compare-btn');
        const clearAllBtn = document.getElementById('term-structure-clear-all-btn');
        
        if (!generateBtn || !clearAllBtn) {
            console.error('❌ Boutons Term Structure non trouvés');
            return;
        }
        
        // Vérifier si au moins un ticker est sélectionné
        const hasTickers = termStructureTickers.length > 0;
        
        // Vérifier si chaque ticker a au moins un strike sélectionné
        let allTickersHaveStrikes = true;
        if (hasTickers) {
            const termStructureSection = document.querySelector('.term-structure-section');
            const tbody = termStructureSection ? termStructureSection.querySelector('.combinations-table tbody') : null;
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                for (const row of rows) {
                    const tickerCell = row.querySelector('.ticker-display');
                    const combinationsDisplay = row.querySelector('.combinations-display');
                    
                    if (tickerCell && combinationsDisplay) {
                        const ticker = tickerCell.textContent;
                        const strikeChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                        
                        // Si ce ticker n'a aucun strike sélectionné
                        if (strikeChips.length === 0) {
                            allTickersHaveStrikes = false;
                            break;
                        }
                    }
                }
            }
        } else {
            allTickersHaveStrikes = false;
        }
        
        // Mettre à jour les boutons
        if (allTickersHaveStrikes && hasTickers) {
            generateBtn.disabled = false;
            generateBtn.classList.remove('disabled');
        } else {
            generateBtn.disabled = true;
            generateBtn.classList.add('disabled');
        }
        
        if (hasTickers) {
            clearAllBtn.disabled = false;
            clearAllBtn.classList.remove('disabled');
        } else {
            clearAllBtn.disabled = true;
            clearAllBtn.classList.add('disabled');
        }
        
        console.log(`🔘 Boutons mis à jour - Tickers: ${hasTickers}, Tous ont strikes: ${allTickersHaveStrikes}`);
    }
    
    // Fonction pour charger les prix spot des tickers
    async function loadSpotPricesForTickers(tickers) {
        for (const ticker of tickers) {
            try {
                const response = await fetch(`/api/tradier/quote/${ticker}`);
                const data = await response.json();
                
                if (data.success && data.spot_price) {
                    const spotElement = document.getElementById(`spot-${ticker}`);
                    if (spotElement) {
                        spotElement.textContent = `Spot: $${data.spot_price.toFixed(2)}`;
                        spotElement.style.color = '#10b981'; // Vert pour le prix spot
                        spotElement.style.fontSize = '0.85em';
                        spotElement.style.marginTop = '2px';
                    }
                } else {
                    const spotElement = document.getElementById(`spot-${ticker}`);
                    if (spotElement) {
                        spotElement.textContent = 'Spot: N/A';
                        spotElement.style.color = '#ef4444'; // Rouge pour erreur
                        spotElement.style.fontSize = '0.85em';
                        spotElement.style.marginTop = '2px';
                    }
                }
            } catch (error) {
                console.error(`❌ Erreur lors du chargement du spot pour ${ticker}:`, error);
                const spotElement = document.getElementById(`spot-${ticker}`);
                if (spotElement) {
                    spotElement.textContent = 'Spot: Error';
                    spotElement.style.color = '#ef4444';
                    spotElement.style.fontSize = '0.85em';
                    spotElement.style.marginTop = '2px';
                }
            }
        }
    }

    // Fonction pour mettre à jour le tableau des combinaisons Term Structure
    let isUpdatingTermStructureTable = false;
    
    async function updateTermStructureCombinationsTable() {
        // Protection contre les appels multiples
        if (isUpdatingTermStructureTable) {
            console.log('⏳ Mise à jour du tableau Term Structure déjà en cours, ignoré');
            return;
        }
        
        isUpdatingTermStructureTable = true;
        
        try {
            // Trouver le tbody du tableau des combinaisons Term Structure
            const termStructureSection = document.querySelector('.term-structure-section');
            const tbody = termStructureSection ? termStructureSection.querySelector('.combinations-table tbody') : null;
            if (!tbody) {
                console.error('❌ Tbody du tableau Term Structure non trouvé');
                return;
            }
        
        // Sauvegarder les strikes actuellement sélectionnés avant de vider le tbody
        const currentSelections = {};
        const existingRows = tbody.querySelectorAll('tr');
        existingRows.forEach(row => {
            const tickerCell = row.querySelector('.ticker-display');
            const maturitySelect = row.querySelector('.maturity-select');
            const combinationsDisplay = row.querySelector('.combinations-display');
            
            if (tickerCell && maturitySelect && combinationsDisplay) {
                const ticker = tickerCell.textContent;
                const selectedStrike = maturitySelect.value;
                const strikeChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                
                if (selectedStrike || strikeChips.length > 0) {
                    currentSelections[ticker] = {
                        selectedMaturity: selectedStrike,
                        maturityChips: Array.from(strikeChips).map(chip => ({
                            text: chip.querySelector('.ticker-chip-text').textContent,
                            days: chip.dataset.maturity
                        }))
                    };
                }
            }
        });
        
        // Vider le tbody
        tbody.innerHTML = '';
        
        // Ajouter une ligne pour chaque ticker unique
        const uniqueTickers = [...new Set(termStructureTickers)];
        
        console.log(`🔍 Tickers dans termStructureTickers: [${termStructureTickers.join(', ')}]`);
        console.log(`🔍 Tickers uniques après Set: [${uniqueTickers.join(', ')}]`);
        
        for (const ticker of uniqueTickers) {
            const row = document.createElement('tr');
            
            // Charger les strikes pour ce ticker depuis l'API
            const strikes = await loadTermStructureTickerStrikes(ticker);
            
            // Trier les strikes par pourcentage (du plus bas au plus haut)
            strikes.sort((a, b) => a.percentage - b.percentage);
            
            // Créer les options du dropdown avec les vraies strikes
            let strikeOptions = '<option value="">Select a strike...</option>';
            strikes.forEach(strike => {
                const isSelected = currentSelections[ticker] && currentSelections[ticker].selectedMaturity === strike.strike.toString();
                strikeOptions += `<option value="${strike.strike}" ${isSelected ? 'selected' : ''}>${strike.percentage_display}</option>`;
            });
            
            row.innerHTML = `
                <td class="ticker-cell">
                    <span class="ticker-display">${ticker}</span>
                    <div class="spot-price-display" id="spot-${ticker}">Loading...</div>
                </td>
                <td class="maturity-cell">
                    <div class="maturity-dropdown-container">
                        <select class="modern-select maturity-select" data-ticker="${ticker}">
                            ${strikeOptions}
                        </select>
                    </div>
                </td>
                <td class="combinations-cell">
                    <div class="tickers-container combinations-display" data-ticker="${ticker}">
                        ${currentSelections[ticker] && currentSelections[ticker].maturityChips.length > 0 ? 
                            currentSelections[ticker].maturityChips.map(chip => `
                                <div class="ticker-chip" data-maturity="${chip.days}">
                                    <span class="ticker-chip-text">${chip.text}</span>
                                    <button class="ticker-chip-remove" onclick="removeTermStructureMaturity('${ticker}', '${chip.days}')">
                                        <i data-lucide="x"></i>
                                    </button>
                                </div>
                            `).join('') :
                            `<div class="empty-tickers">
                                <i data-lucide="layers" class="empty-icon"></i>
                                <span>No strike selected yet</span>
                            </div>`
                        }
                    </div>
                </td>
            `;
            
            tbody.appendChild(row);
        }
        
        // Ajouter les event listeners pour les dropdowns de maturité
        addTermStructureMaturityEventListeners();
        
        // Charger les prix spot pour chaque ticker
        loadSpotPricesForTickers(uniqueTickers);
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Mettre à jour l'état des boutons après la mise à jour du tableau
        // Petit délai pour s'assurer que le DOM est complètement mis à jour
        setTimeout(() => {
            updateTermStructureButtons();
        }, 100);
        
        } catch (error) {
            console.error('❌ Erreur lors de la mise à jour du tableau Term Structure:', error);
        } finally {
            isUpdatingTermStructureTable = false;
        }
    }
    
    // Fonction pour ajouter les event listeners des maturités Term Structure
    function addTermStructureMaturityEventListeners() {
        const termStructureSection = document.querySelector('.term-structure-section');
        const tbody = termStructureSection ? termStructureSection.querySelector('.combinations-table tbody') : null;
        if (!tbody) return;
        
        tbody.querySelectorAll('.maturity-select').forEach(select => {
            // Supprimer les anciens event listeners
            select.removeEventListener('change', select._termStructureMaturityHandler);
            
            // Ajouter le nouvel event listener
            select._termStructureMaturityHandler = function() {
                const ticker = this.dataset.ticker;
                const maturity = this.value;
                
                if (maturity) {
                    addTermStructureMaturity(ticker, maturity);
                    this.value = ''; // Reset le select
                }
            };
            
            select.addEventListener('change', select._termStructureMaturityHandler);
        });
    }
    
    // Fonction pour ajouter un strike Term Structure
    function addTermStructureMaturity(ticker, strikeValue) {
        // Trouver le strike correspondant dans les données chargées
        const strikes = termStructureMaturities[ticker];
        if (!strikes) {
            console.error(`❌ Strikes non trouvés pour ${ticker}`);
            return;
        }
        
        const strike = strikes.find(s => s.strike.toString() === strikeValue.toString());
        if (!strike) {
            console.error(`❌ Strike ${strikeValue} non trouvé pour ${ticker}`);
            return;
        }
        
        // Vérifier si cette combinaison existe déjà
        const selectElement = document.querySelector(`.term-structure-section select[data-ticker="${ticker}"]`);
        if (!selectElement) {
            console.error(`❌ Select pour ${ticker} non trouvé`);
            return;
        }
        
        const combinationsDisplay = selectElement.closest('tr').querySelector('.combinations-display');
        const existingChip = combinationsDisplay.querySelector(`[data-maturity="${strikeValue}"]`);
        
        if (existingChip) {
            showNotification('Ce strike est déjà sélectionné.', 'warning');
            return;
        }
        
        // Créer le chip
        const chip = document.createElement('div');
        chip.className = 'ticker-chip';
        chip.dataset.maturity = strikeValue;
        chip.innerHTML = `
            <span class="ticker-chip-text">${strike.percentage_display}</span>
            <button class="ticker-chip-remove" onclick="removeTermStructureMaturity('${ticker}', '${strikeValue}')">
                <i data-lucide="x"></i>
            </button>
        `;
        
        // Supprimer le message "No strike selected yet" s'il existe
        const emptyMessage = combinationsDisplay.querySelector('.empty-tickers');
        if (emptyMessage) {
            emptyMessage.remove();
        }
        
        combinationsDisplay.appendChild(chip);
        
        // Initialiser les icônes Lucide
        if (window.lucide) {
            lucide.createIcons();
        }
        
        // Mettre à jour l'état des boutons
        updateTermStructureButtons();
        
        showNotification(`${ticker} - ${strike.percentage_display} ajouté`, 'success');
    }
    
    // Fonction pour supprimer un strike Term Structure
    window.removeTermStructureMaturity = function(ticker, strikeValue) {
        const selectElement = document.querySelector(`.term-structure-section select[data-ticker="${ticker}"]`);
        if (!selectElement) {
            console.error(`❌ Select pour ${ticker} non trouvé`);
            return;
        }
        
        const combinationsDisplay = selectElement.closest('tr').querySelector('.combinations-display');
        const chip = combinationsDisplay.querySelector(`[data-maturity="${strikeValue}"]`);
        
        if (chip) {
            chip.remove();
            
            // Si plus de chips, afficher le message vide
            if (combinationsDisplay.children.length === 0) {
                combinationsDisplay.innerHTML = '<div class="empty-tickers"><i data-lucide="layers" class="empty-icon"></i><span>No strike selected yet</span></div>';
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            
            // Mettre à jour l'état des boutons
            updateTermStructureButtons();
            
            showNotification(`Strike ${ticker} - $${strikeValue} supprimé`, 'info');
        }
    }
    
    // Event listener pour le dropdown des tickers Term Structure
    const termStructureTickerSelect = document.getElementById('term-structure-ticker-select');
    
    if (termStructureTickerSelect) {
        termStructureTickerSelect.addEventListener('change', () => {
            const selectedValue = termStructureTickerSelect.value;
            
            if (selectedValue && selectedValue !== '') {
                addTermStructureTicker(selectedValue);
                // Reset du select
                termStructureTickerSelect.value = '';
            }
        });
    }
    
    // Gestion du bouton Clear All Term Structure
    const termStructureClearAllBtn = document.getElementById('term-structure-clear-all-btn');
    if (termStructureClearAllBtn) {
        termStructureClearAllBtn.addEventListener('click', () => {
            // Vider la liste des tickers
            termStructureTickers = [];
            
            // Nettoyer les données en cache et les sélections
            termStructureCurrentSelections = {};
            
            // Vider le tableau des combinaisons Term Structure
            const termStructureSection = document.querySelector('.term-structure-section');
            const tbody = termStructureSection ? termStructureSection.querySelector('.combinations-table tbody') : null;
            if (tbody) {
                tbody.innerHTML = '';
            }
            
            // Remettre le graphique Term Structure à l'état initial
            const termStructureChartDiv = document.getElementById('term-structure-chart');
            if (termStructureChartDiv) {
                // Vider complètement le chartDiv
                termStructureChartDiv.innerHTML = '';
                termStructureChartDiv.classList.remove('js-plotly-plot');
                
                // Recréer complètement le placeholder
                const newTermStructurePlaceholder = document.createElement('div');
                newTermStructurePlaceholder.id = 'term-structure-chart-placeholder';
                newTermStructurePlaceholder.className = 'chart-placeholder';
                newTermStructurePlaceholder.innerHTML = `
                    <div class="placeholder-content">
                        <div class="placeholder-icon">
                            <i data-lucide="bar-chart" style="width: 48px; height: 48px; color: #6b7280;"></i>
                        </div>
                        <h4>Comparison of Term Structure</h4>
                        <p>Add tickers and click "Generate Term Structure" to display the term structure curves</p>
                    </div>
                `;
                
                // Réattacher le placeholder au chartDiv
                termStructureChartDiv.appendChild(newTermStructurePlaceholder);
                
                // Réinitialiser les icônes Lucide
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            
            // Masquer les statistiques Term Structure et vider leur contenu
            const termStructureStatisticsDiv = document.getElementById('term-structure-statistics');
            if (termStructureStatisticsDiv) {
                termStructureStatisticsDiv.classList.add('hidden');
                // Vider le contenu des statistiques Term Structure
                const termStructureStatsContainer = document.getElementById('term-structure-comparison-stats');
                if (termStructureStatsContainer) {
                    termStructureStatsContainer.innerHTML = '<p>Aucune donnée disponible</p>';
                }
            }
            
            // Mettre à jour l'affichage des tickers sélectionnés
            renderTermStructureSelectedTickers();
            
            // Mettre à jour l'état des boutons
            updateTermStructureButtons();
            
            // Mettre à jour les compteurs
            updateTickerCounts();
            
            // Afficher une notification
            showNotification('Toutes les sélections Term Structure ont été effacées', 'info');
        });
    }
    
    // Fonction pour récupérer les données de term structure via Tradier (avec cache)
    async function fetchTermStructure(symbol, strike) {
        // Vérifier le cache d'abord
        const cacheKey = `${symbol}-${strike}`;
        if (termStructureDataCache.has(cacheKey)) {
            console.log(`💾 Données de term structure récupérées du cache pour ${symbol}-$${strike}`);
            return termStructureDataCache.get(cacheKey);
        }
        
        const url = `/api/term-structure/${encodeURIComponent(symbol)}/${strike}?_t=${Date.now()}`;
        console.log(`🔗 URL générée: ${url}`);
        
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Mettre en cache les données (cache valide pendant 5 minutes)
            termStructureDataCache.set(cacheKey, data);
            console.log(`💾 Données de term structure mises en cache pour ${symbol}-$${strike}`);
            
            // Nettoyer le cache après 5 minutes
            setTimeout(() => {
                termStructureDataCache.delete(cacheKey);
                console.log(`🗑️ Cache expiré pour ${symbol}-$${strike}`);
            }, 5 * 60 * 1000);
            
            return data;
        } catch (error) {
            console.error('Error fetching term structure from Tradier:', error);
            throw error;
        }
    }
    
    // Fonction pour créer le graphique de term structure
    function createTermStructureChart(allData) {
        const chartDiv = document.getElementById('term-structure-chart');
        if (!chartDiv) {
            console.error('❌ Élément term-structure-chart non trouvé');
            return;
        }
        
        // Supprimer le spinner de chargement et masquer le contenu du placeholder
        const placeholder = document.getElementById('term-structure-chart-placeholder');
        if (placeholder) {
            // Supprimer le spinner de chargement s'il existe
            const loadingSpinner = placeholder.querySelector('.loading-spinner');
            if (loadingSpinner) {
                loadingSpinner.remove();
            }
            
            // Masquer seulement le contenu du placeholder, pas le placeholder lui-même
            const placeholderContent = placeholder.querySelector('.placeholder-content');
            if (placeholderContent) {
                placeholderContent.style.display = 'none';
            }
        }
        
        if (!allData || allData.length === 0) {
            // Réafficher le contenu du placeholder avec message d'erreur
            if (placeholder) {
                const placeholderContent = placeholder.querySelector('.placeholder-content');
                if (placeholderContent) {
                    placeholderContent.style.display = 'block';
                    placeholderContent.innerHTML = '<div class="chart-error"><div class="chart-error-icon"><i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i></div><div class="chart-error-title">Données insuffisantes</div><div class="chart-error-message">Aucune donnée de term structure disponible pour créer le graphique</div></div>';
                }
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            return;
        }
        
        // Préparer les données pour Plotly
        const traces = [];
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
        
        allData.forEach((data, index) => {
            if (data.success && data.term_structure && data.term_structure.length > 0) {
                const termStructure = data.term_structure;
                const x = termStructure.map(item => item.expiration);
                const y = termStructure.map(item => item.implied_volatility * 100); // Convertir en pourcentage
                
                const color = colors[index % colors.length];
                const symbol = data.symbol;
                const strike = data.strike;
                const spotPrice = data.spot_price;
                
                const trace = {
                    x: x,
                    y: y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `${symbol} - $${strike.toFixed(2)}`,
                    line: { color: color, width: 1 },
                    marker: { size: 3, color: color },
                    hovertemplate: 
                        `<b>${symbol}</b><br>` +
                        '<b>Strike:</b> $' + strike.toFixed(2) + '<br>' +
                        '<b>Expiration:</b> %{x} %{customdata}<br>' +
                        '<b>IV:</b> %{y:.2f}%<br>' +
                        '<b>Spot:</b> $' + spotPrice.toFixed(2) + '<br>' +
                        '<extra></extra>',
                    customdata: termStructure.map(item => `(${item.days_to_exp} jours ouvrés)`)
                };
                
                traces.push(trace);
            }
        });
        
        if (traces.length === 0) {
            // Réafficher le contenu du placeholder avec message d'erreur
            if (placeholder) {
                const placeholderContent = placeholder.querySelector('.placeholder-content');
                if (placeholderContent) {
                    placeholderContent.style.display = 'block';
                    placeholderContent.innerHTML = '<div class="chart-error"><div class="chart-error-icon"><i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i></div><div class="chart-error-title">Données insuffisantes</div><div class="chart-error-message">Aucune donnée de term structure disponible pour créer le graphique</div></div>';
                }
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            return;
        }
        
        // Détecter la taille de l'écran pour la responsivité
        const screenWidth = window.innerWidth;
        const isMobile = screenWidth < 768;
        const isTablet = screenWidth >= 768 && screenWidth < 1024;
        const isDesktop = screenWidth >= 1024;
        
        // Configuration responsive pour l'axe X
        let xAxisConfig = {
            title: 'Date d\'expiration',
            type: 'date',
            gridcolor: 'rgba(55, 65, 81, 0.3)',
            zerolinecolor: 'rgba(107, 114, 128, 0.5)',
            showbackground: false,
            titlefont: { 
                color: '#ffffff', 
                size: isMobile ? 12 : 14, 
                family: 'Segoe UI' 
            },
            tickfont: { 
                color: '#d1d5db', 
                size: isMobile ? 10 : 12, 
                family: 'Segoe UI' 
            },
            showgrid: true,
            zeroline: false
        };
        
        // Configuration responsive pour les dates
        if (isMobile) {
            xAxisConfig.tickformat = '%m/%d';
            xAxisConfig.tickangle = -60;
            xAxisConfig.nticks = 8;
        } else if (isTablet) {
            xAxisConfig.tickformat = '%m/%d/%y';
            xAxisConfig.tickangle = -45;
            xAxisConfig.nticks = 12;
        } else {
            xAxisConfig.tickformat = '%m/%d/%Y';
            xAxisConfig.tickangle = -45;
            xAxisConfig.nticks = 20;
        }
        
        // Configuration du graphique
        const layout = {
            // Pas de titre dans le graphique - il est maintenant dans la div HTML
            xaxis: xAxisConfig,
            yaxis: {
                title: 'Volatilité Implicite (%)',
                gridcolor: 'rgba(55, 65, 81, 0.3)',
                zerolinecolor: 'rgba(107, 114, 128, 0.5)',
                showbackground: false,
                titlefont: { 
                    color: '#ffffff', 
                    size: isMobile ? 12 : 14, 
                    family: 'Segoe UI' 
                },
                tickfont: { 
                    color: '#d1d5db', 
                    size: isMobile ? 10 : 12, 
                    family: 'Segoe UI' 
                },
                showgrid: true,
                zeroline: false
            },
            plot_bgcolor: 'rgba(0,0,0,0)',
            paper_bgcolor: 'rgba(0,0,0,0)',
            font: {
                color: '#ffffff',
                family: 'Segoe UI'
            },
            showlegend: true,
            legend: {
                font: { 
                    color: '#ffffff', 
                    size: isMobile ? 11 : 13, 
                    family: 'Segoe UI' 
                },
                bgcolor: 'rgba(0,0,0,0.7)',
                bordercolor: 'rgba(55, 65, 81, 0.5)',
                borderwidth: 1,
                x: isMobile ? 0.02 : 0.02,
                y: isMobile ? 0.95 : 0.98,
                xanchor: 'left',
                yanchor: 'top'
            },
            margin: {
                l: isMobile ? 50 : 60,
                r: isMobile ? 20 : 40,
                b: isMobile ? 100 : 120,
                t: isMobile ? 60 : 80
            },
            hovermode: 'x unified',
            hoverlabel: {
                bgcolor: 'rgba(17, 24, 39, 0.95)',
                bordercolor: '#374151',
                font: {
                    color: '#f9fafb',
                    family: 'Arial, sans-serif',
                    size: 12
                }
            }
        };
        
        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
            displaylogo: false,
            scrollZoom: true,
            editable: false,
            staticPlot: false
        };
        
        // Créer le graphique
        Plotly.newPlot(chartDiv, traces, layout, config);
        
        console.log(`✅ Graphique de term structure créé avec ${traces.length} courbes`);
        
        // Gérer le redimensionnement responsive
        const handleResize = () => {
            const newScreenWidth = window.innerWidth;
            const newIsMobile = newScreenWidth < 768;
            const newIsTablet = newScreenWidth >= 768 && newScreenWidth < 1024;
            
            // Mettre à jour la configuration responsive
            let newXAxisConfig = { ...layout.xaxis };
            let newLegendConfig = { ...layout.legend };
            let newMarginConfig = { ...layout.margin };
            
            // Mettre à jour l'axe X
            if (newIsMobile) {
                newXAxisConfig.tickformat = '%m/%d';
                newXAxisConfig.tickangle = -60;
                newXAxisConfig.nticks = 8;
                newXAxisConfig.titlefont.size = 12;
                newXAxisConfig.tickfont.size = 10;
            } else if (newIsTablet) {
                newXAxisConfig.tickformat = '%m/%d/%y';
                newXAxisConfig.tickangle = -45;
                newXAxisConfig.nticks = 12;
                newXAxisConfig.titlefont.size = 14;
                newXAxisConfig.tickfont.size = 12;
            } else {
                newXAxisConfig.tickformat = '%m/%d/%Y';
                newXAxisConfig.tickangle = -45;
                newXAxisConfig.nticks = 20;
                newXAxisConfig.titlefont.size = 14;
                newXAxisConfig.tickfont.size = 12;
            }
            
            // Mettre à jour la légende
            newLegendConfig.font.size = newIsMobile ? 11 : 13;
            newLegendConfig.y = newIsMobile ? 0.95 : 0.98;
            
            // Mettre à jour les marges
            newMarginConfig.l = newIsMobile ? 50 : 60;
            newMarginConfig.r = newIsMobile ? 20 : 40;
            newMarginConfig.b = newIsMobile ? 100 : 120;
            newMarginConfig.t = newIsMobile ? 60 : 80;
            
            // Mettre à jour l'axe Y
            const newYAxisConfig = { ...layout.yaxis };
            newYAxisConfig.titlefont.size = newIsMobile ? 12 : 14;
            newYAxisConfig.tickfont.size = newIsMobile ? 10 : 12;
            
            // Appliquer les changements
            Plotly.relayout(chartDiv, {
                'xaxis': newXAxisConfig,
                'yaxis': newYAxisConfig,
                'legend': newLegendConfig,
                'margin': newMarginConfig
            });
        };
        
        // Ajouter l'écouteur de redimensionnement
        window.addEventListener('resize', handleResize);
        
        // Nettoyer l'écouteur quand le graphique est détruit
        const originalDestroy = chartDiv._plotly ? chartDiv._plotly.destroy : null;
        if (originalDestroy) {
            chartDiv._plotly.destroy = function() {
                window.removeEventListener('resize', handleResize);
                return originalDestroy.apply(this, arguments);
            };
        }
        
        // Gérer le toggle de la légende pour Term Structure
        const termStructureLegendToggleBtn = document.getElementById('term-structure-legend-toggle-btn');
        let termStructureLegendVisible = true;
        
        if (termStructureLegendToggleBtn) {
            termStructureLegendToggleBtn.addEventListener('click', function() {
                termStructureLegendVisible = !termStructureLegendVisible;
                
                // Mettre à jour l'icône et le texte
                const icon = termStructureLegendToggleBtn.querySelector('.legend-toggle-icon');
                const text = termStructureLegendToggleBtn.querySelector('.legend-toggle-text');
                
                if (termStructureLegendVisible) {
                    icon.setAttribute('data-lucide', 'eye');
                    text.textContent = 'Legend';
                    termStructureLegendToggleBtn.title = 'Hide Legend';
                } else {
                    icon.setAttribute('data-lucide', 'eye-off');
                    text.textContent = 'Show';
                    termStructureLegendToggleBtn.title = 'Show Legend';
                }
                
                // Réinitialiser l'icône Lucide
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                // Mettre à jour la légende dans le graphique
                if (chartDiv && chartDiv.data) {
                    Plotly.relayout(chartDiv, {
                        'showlegend': termStructureLegendVisible
                    });
                }
            });
        }
    }
    
    // Fonction pour mettre à jour les statistiques de comparaison de term structure
    function updateTermStructureComparisonStatistics(allData) {
        const container = document.getElementById('term-structure-comparison-stats');
        
        // Toujours vider le conteneur d'abord
        container.innerHTML = '';
        
        if (!allData || allData.length === 0) {
            container.innerHTML = '<p>Aucune donnée disponible</p>';
            return;
        }
        
        let html = '<div class="comparison-stats-grid">';
        
        allData.forEach((data, index) => {
            // Calculer les statistiques à partir des données de term structure
            let stats = {};
            
            if (data.term_structure && data.term_structure.length > 0) {
                const ivs = data.term_structure.map(item => item.implied_volatility);
                const daysToExp = data.term_structure.map(item => item.days_to_exp);
                
                stats = {
                    total_maturities: data.term_structure.length,
                    min_iv: Math.min(...ivs),
                    max_iv: Math.max(...ivs),
                    avg_iv: ivs.reduce((sum, iv) => sum + iv, 0) / ivs.length,
                    min_days: Math.min(...daysToExp),
                    max_days: Math.max(...daysToExp),
                    avg_days: daysToExp.reduce((sum, days) => sum + days, 0) / daysToExp.length
                };
            } else {
                // Fallback
                stats = {
                    total_maturities: 0,
                    min_iv: 0,
                    max_iv: 0,
                    avg_iv: 0,
                    min_days: 0,
                    max_days: 0,
                    avg_days: 0
                };
            }
            
            html += `
                <div class="comparison-stat-card">
                    <div class="stat-card-header">
                        <h4>${data.symbol}</h4>
                        <span class="stat-card-price">$${data.spot_price.toFixed(2)}</span>
                    </div>
                    <div class="stat-card-content">
                        <div class="stat-row">
                            <span class="stat-label">Strike:</span>
                            <span class="stat-value">$${data.strike.toFixed(2)}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Maturités:</span>
                            <span class="stat-value">${stats.total_maturities}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Min:</span>
                            <span class="stat-value">${(stats.min_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Max:</span>
                            <span class="stat-value">${(stats.max_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">IV Moy:</span>
                            <span class="stat-value">${(stats.avg_iv * 100).toFixed(1)}%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Jours (Min-Max):</span>
                            <span class="stat-value">${stats.min_days}-${stats.max_days}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Source:</span>
                            <span class="stat-value">Tradier API</span>
                        </div>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
        
        // Afficher la section des statistiques
        const termStructureStatisticsDiv = document.getElementById('term-structure-statistics');
        if (termStructureStatisticsDiv) {
            termStructureStatisticsDiv.classList.remove('hidden');
        }
    }
    
    // Fonction principale pour générer la term structure
    async function generateTermStructure() {
        const generateBtn = document.getElementById('term-structure-compare-btn');
        if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i data-lucide="loader-2" class="button-icon animate-spin"></i><span>Génération...</span>';
            if (window.lucide) {
                lucide.createIcons();
            }
        }
        
        // Mettre à jour le statut API
        updateApiStatus('checking');
        
        // Démarrer le chronomètre pour le temps de réponse
        const startTime = performance.now();
        
        // Afficher l'icône de chargement dans le chart
        const chartDiv = document.getElementById('term-structure-chart');
        const placeholder = document.getElementById('term-structure-chart-placeholder');
        
        if (placeholder) {
            placeholder.innerHTML = '<div class="loading-spinner"><div class="spinner"></div><div class="loading-text">Comparaison de la structure par terme...</div></div>';
        }
        
        try {
            // Récupérer toutes les combinaisons sélectionnées
            const termStructureSection = document.querySelector('.term-structure-section');
            const tbody = termStructureSection ? termStructureSection.querySelector('.combinations-table tbody') : null;
            
            if (!tbody) {
                throw new Error('Tableau des combinaisons non trouvé');
            }
            
            const rows = tbody.querySelectorAll('tr');
            const combinations = [];
            
            for (const row of rows) {
                const tickerCell = row.querySelector('.ticker-display');
                const combinationsDisplay = row.querySelector('.combinations-display');
                
                if (tickerCell && combinationsDisplay) {
                    const ticker = tickerCell.textContent.trim();
                    console.log(`🔍 Ticker extrait: "${ticker}"`);
                    const strikeChips = combinationsDisplay.querySelectorAll('.ticker-chip');
                    
                    for (const chip of strikeChips) {
                        const strikeText = chip.querySelector('.ticker-chip-text').textContent;
                        console.log(`🔍 Strike text extrait: "${strikeText}"`);
                        
                        // Extraire le strike en dollars du texte (ex: "95.2% ($380.00)" -> 380.00)
                        const strikeMatch = strikeText.match(/\$(\d+\.?\d*)/);
                        if (strikeMatch) {
                            const strike = parseFloat(strikeMatch[1]);
                            console.log(`✅ Strike extrait: ${strike} pour ${ticker}`);
                            combinations.push({ ticker, strike });
                        } else {
                            console.log(`❌ Impossible d'extraire le strike de: "${strikeText}"`);
                        }
                    }
                }
            }
            
            if (combinations.length === 0) {
                throw new Error('Aucune combinaison sélectionnée');
            }
            
            console.log(`🚀 Génération de la term structure pour ${combinations.length} combinaisons:`, combinations);
            
            // Récupérer les données pour chaque combinaison EN PARALLÈLE (optimisation)
            console.log(`🚀 Récupération des données en parallèle pour ${combinations.length} combinaisons...`);
            const startTime = performance.now();
            
            const allData = [];
            const errors = [];
            
            // Traitement en parallèle par lots de 3 pour éviter la surcharge
            const batchSize = 3;
            for (let i = 0; i < combinations.length; i += batchSize) {
                const batch = combinations.slice(i, i + batchSize);
                console.log(`📦 Traitement du lot ${Math.floor(i/batchSize) + 1}/${Math.ceil(combinations.length/batchSize)}: [${batch.map(c => `${c.ticker}-$${c.strike}`).join(', ')}]`);
                
                const promises = batch.map(async (combo) => {
                try {
                    console.log(`📊 Récupération des données pour ${combo.ticker} - Strike $${combo.strike}...`);
                    const data = await fetchTermStructure(combo.ticker, combo.strike);
                        return { success: true, data, combo };
                } catch (error) {
                    console.error(`❌ Erreur pour ${combo.ticker} - Strike $${combo.strike}:`, error);
                        return { success: false, error, combo };
                    }
                });
                
                const results = await Promise.all(promises);
                
                results.forEach(result => {
                    if (result.success) {
                        allData.push(result.data);
                    } else {
                        errors.push(result);
                    }
                });
                
                // Petite pause entre les lots pour éviter la surcharge
                if (i + batchSize < combinations.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            const endTime = performance.now();
            const totalTime = Math.round(endTime - startTime);
            console.log(`⏱️ Récupération terminée en ${totalTime}ms (${allData.length} succès, ${errors.length} erreurs)`);
            
            // Créer le graphique
            createTermStructureChart(allData);
            
            // Mettre à jour les statistiques de comparaison
            updateTermStructureComparisonStatistics(allData);
            
            // Afficher une notification de succès avec statistiques de performance
            const successMessage = `Term structure générée avec ${allData.length} courbes en ${totalTime}ms`;
            if (errors.length > 0) {
                showNotification(`${successMessage} (${errors.length} erreurs)`, 'warning');
            } else {
                showNotification(successMessage, 'success');
            }
            
            // Calculer le temps de réponse
            const termEndTime = performance.now();
            const responseTime = Math.round(termEndTime - startTime);
            
            // Mettre à jour le statut API en cas de succès
            updateApiStatus('connected', responseTime);
            
            // Afficher les statistiques de performance dans la console
            console.log(`📊 Statistiques de performance Term Structure:`);
            console.log(`   • Temps total: ${totalTime}ms`);
            console.log(`   • Combinaisons traitées: ${combinations.length}`);
            console.log(`   • Succès: ${allData.length}`);
            console.log(`   • Erreurs: ${errors.length}`);
            console.log(`   • Temps moyen par combinaison: ${Math.round(totalTime / combinations.length)}ms`);
            console.log(`   • Cache utilisé: ${termStructureDataCache.size} entrées`);
            
        } catch (error) {
            console.error('❌ Erreur lors de la génération de la term structure:', error);
            updateApiStatus('error');
            showNotification(`Erreur: ${error.message}`, 'error');
            
            // Réafficher le contenu du placeholder en cas d'erreur
            const placeholder = document.getElementById('term-structure-chart-placeholder');
            if (placeholder) {
                const placeholderContent = placeholder.querySelector('.placeholder-content');
                if (placeholderContent) {
                    placeholderContent.style.display = 'block';
                    placeholderContent.innerHTML = `
                        <div class="chart-error">
                            <div class="chart-error-icon">
                                <i data-lucide="x-circle" style="width: 24px; height: 24px; color: #ef4444;"></i>
                            </div>
                            <div class="chart-error-title">Erreur de génération</div>
                            <div class="chart-error-message">${error.message}</div>
                        </div>
                    `;
                }
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
        } finally {
            // Restaurer le bouton
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i data-lucide="bar-chart-3" class="button-icon"></i><span>Generate Term Structure</span>';
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
        }
    }
    
    // Event listener pour le bouton Generate Term Structure
    const termStructureCompareBtn = document.getElementById('term-structure-compare-btn');
    if (termStructureCompareBtn) {
        termStructureCompareBtn.addEventListener('click', generateTermStructure);
    }
    
    // Chargement initial des tickers pour toutes les sections
    console.log('🚀 Initialisation des tickers pour toutes les sections...');
    loadGlobalAvailableTickers().then(async () => {
        console.log('✅ Tickers chargés avec succès');
        
        // Pré-vérifier TOUS les tickers disponibles pour identifier ceux sans options
        console.log(`🔍 Pré-vérification de TOUS les tickers (${globalAvailableTickers.length} tickers, sans erreurs 404)...`);
        
        // Démarrer la barre de progression
        startProgressBar();
        
        // Valider tous les tickers en parallèle (par lots de 5 pour éviter la surcharge)
        const batchSize = 5;
        const allTickers = globalAvailableTickers.map(t => t.symbol);
        const totalBatches = Math.ceil(allTickers.length / batchSize);
        
        for (let i = 0; i < allTickers.length; i += batchSize) {
            const batch = allTickers.slice(i, i + batchSize);
            const currentBatch = Math.floor(i/batchSize) + 1;
            console.log(`📦 Validation du lot ${currentBatch}/${totalBatches}: [${batch.join(', ')}]`);
            
            // Valider le lot en parallèle
            const promises = batch.map(async (ticker) => {
                try {
                    await validateTickerHasOptions(ticker);
                } catch (error) {
                    console.warn(`⚠️ Erreur lors de la pré-vérification de ${ticker}:`, error);
                }
            });
            
            await Promise.all(promises);
            
            // Mettre à jour la barre de progression
            const progress = Math.round((currentBatch / totalBatches) * 90); // 90% max pendant la vérification
            updateProgressBar(progress);
            
            // Petite pause entre les lots pour éviter la surcharge
            if (i + batchSize < allTickers.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        // Filtrer automatiquement les tickers sans options
        filterTickersWithoutOptions();
        
        // Synchroniser toutes les sections
        synchronizeTickers();
        
        // Finaliser la progression
        completeProgressBar();
        
        // Charger les tickers avec animation
        loadTradierSymbols();
    }).catch(error => {
        console.error('❌ Erreur lors du chargement initial des tickers:', error);
        // En cas d'erreur, essayer quand même de charger les tickers
        loadTradierSymbols();
    });
     
    }); // Fermeture de DOMContentLoaded
</script>

<!-- CSS pour la hiérarchie des titres -->
<style>
/* Titres principaux des sections (plus grands) */
.main-section-title {
    font-size: 1.75rem !important;
    font-weight: 700 !important;
    color: #ffffff !important;
    margin: 0 !important;
    line-height: 1.2 !important;
}

/* Sous-titres des sections (plus petits) */
.sub-section-title {
    font-size: 0.9rem !important;
    font-weight: 400 !important;
    color: #94a3b8 !important;
    margin: 0.5rem 0 0 0 !important;
    line-height: 1.4 !important;
}

/* Titres principaux des graphiques */
.chart-main-title {
    font-size: 1.25rem !important;
    font-weight: 600 !important;
    color: #ffffff !important;
    margin: 0 !important;
    line-height: 1.3 !important;
}

/* Sous-titres des graphiques */
.chart-sub-title {
    font-size: 0.8rem !important;
    font-weight: 400 !important;
    color: #9ca3af !important;
    margin: 0.25rem 0 0 0 !important;
    line-height: 1.4 !important;
}

/* Responsive pour les titres */
@media (max-width: 768px) {
    .main-section-title {
        font-size: 1.4rem !important;
    }
    
    .sub-section-title {
        font-size: 0.8rem !important;
    }
    
    .chart-main-title {
        font-size: 1.1rem !important;
    }
    
    .chart-sub-title {
        font-size: 0.75rem !important;
    }
}

@media (max-width: 480px) {
    .main-section-title {
        font-size: 1.25rem !important;
    }
    
    .sub-section-title {
        font-size: 0.75rem !important;
    }
    
    .chart-main-title {
        font-size: 1rem !important;
    }
    
    .chart-sub-title {
        font-size: 0.7rem !important;
    }
}

/* Styles pour l'animation de chargement des tickers */
.symbol-select-container {
    position: relative;
}


/* Désactiver le select pendant le chargement */
.form-input:disabled,
.modern-select:disabled {
    background-color: #374151;
    color: #9ca3af;
    cursor: not-allowed;
    opacity: 0.7;
}



/* Styles pour la barre de progression */
.progress-card {
    background: #1f2937;
    border: 1px solid #374151;
    border-radius: 8px;
    padding: 16px;
    margin-top: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-content {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.progress-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.progress-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
}

.progress-dot {
    width: 8px;
    height: 8px;
    background: #3b82f6;
    border-radius: 50%;
    animation: pulse 2s infinite;
}

.progress-text {
    font-size: 0.875rem;
    color: #e5e7eb;
    font-weight: 500;
}

.progress-bar-container {
    display: flex;
    align-items: center;
    gap: 12px;
}

.progress-bar {
    flex: 1;
    height: 8px;
    background: #374151;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #1d4ed8);
    border-radius: 4px;
    width: 0%;
    transition: width 0.3s ease;
    position: relative;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: shimmer 2s infinite;
}

.progress-percentage {
    min-width: 40px;
    text-align: right;
}

.progress-percentage span {
    font-size: 0.875rem;
    color: #9ca3af;
    font-weight: 600;
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

@keyframes shimmer {
    0% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(100%);
    }
}

/* Responsive pour mobile */
@media screen and (max-width: 768px) {
    .progress-card {
        padding: 12px;
        margin-top: 12px;
    }
    
    .progress-text {
        font-size: 0.8rem;
    }
    
    .progress-percentage span {
        font-size: 0.8rem;
    }
}

</style>

{% endblock %} 