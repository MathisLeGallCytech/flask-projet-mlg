{% extends "base_flask.html" %}

{% block title %}Analysis – Performance Comparison{% endblock %}

{% block content %}
<div class="dashboard-container">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <h2>Navigation</h2>
        </div>
        <nav class="sidebar-nav">
            <ul>
                <li class="nav-item">
                    <a href="{{ url_for('index') }}" class="nav-link">
                        <i data-lucide="home"></i>
                        <span>Home</span>
                    </a>
                </li>
                                    <li class="nav-item">
                        <a href="{{ url_for('cv_mathis_le_gall') }}" class="nav-link">
                            <i data-lucide="user"></i>
                            <span>Mathis Le Gall CV</span>
                        </a>
                    </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link dropdown-toggle" onclick="toggleDropdown(event)">
                        <i data-lucide="trending-up"></i>
                        <span>Market Overview</span>
                        <i data-lucide="chevron-down" class="dropdown-arrow"></i>
                    </a>
                    <ul class="dropdown-menu">
                        <li class="dropdown-item">
                            <a href="{{ url_for('indices_actions') }}" class="nav-link">
                                <i data-lucide="candlestick-chart"></i>
                                <span>Indices & Stocks</span>
                            </a>
                        </li>
                        <li class="dropdown-item">
                            <a href="{{ url_for('crypto') }}" class="nav-link">
                                <i data-lucide="bar-chart"></i>
                                <span>Cryptocurrencies</span>
                            </a>
                        </li>
                        <li class="dropdown-item">
                            <a href="{{ url_for('rates_fx') }}" class="nav-link">
                                <i data-lucide="trending-up"></i>
                                <span>Rates & FX</span>
                            </a>
                        </li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('analyse_actions_indices') }}" class="nav-link active">
                        <i data-lucide="activity"></i>
                        <span>Market Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('call_put') }}" class="nav-link">
                        <i data-lucide="line-chart"></i>
                        <span>Call & Put</span>
                    </a>
                </li>

                <li class="nav-item">
                    <a href="{{ url_for('volatility_surface') }}" class="nav-link">
                        <i data-lucide="thermometer"></i>
                        <span>Implied Volatility Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('analyse_volatility') }}" class="nav-link">
                        <i data-lucide="twitter"></i>
                        <span>Tweet Analysis</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="{{ url_for('description_app') }}" class="nav-link">
                        <i data-lucide="info"></i>
                        <span>App Description</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <header class="content-header">
            <div class="main-header-flex">
                <div class="main-header-left">
                </div>
                <div class="main-header-center">
                    <!-- Space to balance the layout -->
                </div>
                <div class="main-header-right">
                    <h1 class="header-title">Market Analysis</h1>
                </div>
            </div>
        </header>

        <!-- Content -->
        <div class="content-area">
            <div class="page-header">
                <div class="header-content">
                    <div class="header-left">
                        <h1 class="page-title">
                            <i data-lucide="activity" class="title-icon"></i>
                            Market Analysis
                        </h1>
                        <p class="page-subtitle">
                            Performance comparison and risk metrics
                        </p>
                    </div>
                    
                    <!-- API Status Indicator -->
                    <div id="api-status" class="api-status-card">
                        <div class="status-indicator">
                            <div id="api-status-indicator" class="status-dot"></div>
                            <span id="api-status-text" class="status-text">Checking API...</span>
                        </div>
                        <div class="status-details">
                            <div class="api-name">Yahoo Finance API</div>
                            <div id="api-response-time" class="response-time">--</div>
                        </div>
                        <div class="status-meta">
                            <i data-lucide="database" class="meta-icon"></i>
                            <span class="meta-text">30 actions</span>
                        </div>
                    </div>
                </div>
            </div>

            <main class="main-content-area">
                <section class="analysis-section">
                <h3>Performance Comparison (Base 100)</h3>
                <div class="search-container">
                    <div class="search-input">
                        <label>Search</label>
                        <input id="tag-search" type="text" placeholder="Type a symbol or name..." />
                        <div id="tag-suggestions" class="suggestions-dropdown"></div>
                    </div>
                    <div class="dropdown-container">
                        <label>Dropdown</label>
                        <select id="tag-dropdown">
                            <option value="">Choose an instrument…</option>
                        </select>
                    </div>
                    <div class="date-input">
                        <label for="tag-start">Start Date</label>
                        <input id="tag-start" type="date" value="2015-01-01" />
                    </div>
                    <div class="date-input">
                        <label for="tag-end">End Date</label>
                        <input id="tag-end" type="date" />
                    </div>
                    <div class="scale-container">
                        <label>Scale</label>
                        <div class="scale-toggle">
                            <input id="perf-log-scale" type="checkbox" />
                            <span>Logarithmic</span>
                        </div>
                    </div>
                    <div class="action-button">
                        <button id="tag-plot">Plot</button>
                    </div>
                </div>
                <div class="selection-container">
                    <div class="selection-label">Selection</div>
                    <div id="tag-selected" class="tag-chips"></div>
                </div>
                <div class="analysis-chart-container">
                    <div class="analysis-chart-canvas-container">
                        <canvas id="perf-chart"></canvas>
                    </div>
                </div>
                
                <!-- Table of Risk Metrics -->
                <div class="risk-metrics-section">
                    <h3>Risk Metrics</h3>
                    <div class="risk-metrics-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <!-- Column headers will be generated dynamically -->
                                </tr>
                            </thead>
                            <tbody id="risk-table-body" >
                                <!-- Content will be generated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
            </main>
        </div>

    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
<script>
    // Initialize Lucide icons
    lucide.createIcons();
    
    // Gestion du menu mobile (si l'élément existe)
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    if (mobileMenuBtn) {
        mobileMenuBtn.addEventListener('click', () => {
            document.querySelector('.sidebar').classList.toggle('open');
        });
        
        // Fermer le menu en cliquant en dehors
        document.addEventListener('click', (e) => {
            const sidebar = document.querySelector('.sidebar');
            
            if (!sidebar.contains(e.target) && !mobileMenuBtn.contains(e.target)) {
                sidebar.classList.remove('open');
            }
        });
    }
    
    // Fonction pour mettre à jour le statut de l'API
    function updateApiStatus(status, responseTime = null) {
        const indicator = document.getElementById('api-status-indicator');
        const statusText = document.getElementById('api-status-text');
        const responseTimeEl = document.getElementById('api-response-time');
        
        // Supprimer toutes les classes de couleur
        indicator.classList.remove('connected', 'error', 'checking');
        
        switch(status) {
            case 'connected':
                indicator.classList.add('connected');
                statusText.textContent = 'API Connected';
                if (responseTime) {
                    responseTimeEl.textContent = `${responseTime}ms`;
                }
                break;
            case 'error':
                indicator.classList.add('error');
                statusText.textContent = 'API Offline';
                responseTimeEl.textContent = 'Error';
                break;
            case 'checking':
                indicator.classList.add('checking');
                statusText.textContent = 'Checking API...';
                responseTimeEl.textContent = '--';
                break;
        }
    }
    let perfChart = null;
    let availableInstruments = [];
    let tagSelected = [
        { symbol: '^GSPC', label: 'S&P 500' },
        { symbol: '^FCHI', label: 'CAC 40' },
    ];

    function renderTagSelected() {
        const sel = document.getElementById('tag-selected');
        sel.innerHTML = '';
        tagSelected.forEach((item, idx) => {
            const chip = document.createElement('div');
            chip.className = 'flex items-center gap-2 px-2 py-1 rounded-full text-sm';
            chip.innerHTML = `<span>${item.label}</span><button aria-label="Supprimer" class="h-5 w-5 grid place-items-center rounded-full bg-destructive text-destructive-foreground">×</button>`;
            chip.querySelector('button').addEventListener('click', () => {
                tagSelected = tagSelected.filter(s => s.symbol !== item.symbol);
                renderTagSelected();
            });
            sel.appendChild(chip);
        });
    }

    function renderTagSuggestions(filter = '') {
        const sugg = document.getElementById('tag-suggestions');
        const f = (filter || '').toLowerCase();
        const filtered = availableInstruments
            .filter(x => x.symbol.toLowerCase().includes(f) || x.label.toLowerCase().includes(f))
            .slice(0, 50);
        if (!f) { sugg.classList.add('hidden'); sugg.innerHTML = ''; return; }
        sugg.classList.remove('hidden');
        sugg.innerHTML = '';
        filtered.forEach(item => {
            const already = tagSelected.find(s => s.symbol === item.symbol);
            if (already) return;
            const row = document.createElement('div');
            row.className = 'flex items-center justify-between p-2 rounded hover: cursor-pointer';
            row.innerHTML = `<span class="truncate">${item.label} <span >(${item.symbol})</span></span><button class="px-2 py-1 text-xs   rounded">Add</button>`;
            row.querySelector('button').addEventListener('click', (e) => {
                e.stopPropagation();
                tagSelected.push(item);
                renderTagSelected();
                renderTagSuggestions(document.getElementById('tag-search').value);
            });
            sugg.appendChild(row);
        });
        lucide.createIcons();
    }

    async function loadMarketData() {
        try {
            updateApiStatus('checking');
            const startTime = performance.now();
            
            const resp = await fetch('/api/market-data');
            const data = await resp.json();
            
            const endTime = performance.now();
            const responseTime = Math.round(endTime - startTime);
            
            if (data.error) {
                throw new Error(data.error);
            }
            
            updateApiStatus('connected', responseTime);
            
            availableInstruments = [];
            
            // Ajouter les indices
            Object.entries(data.indices).forEach(([name, idx]) => {
                availableInstruments.push({ 
                    symbol: idx.symbol, 
                    label: (idx.displayName || idx.symbol),
                    category: 'Indices'
                });
            });
            
            // Ajouter les actions
            Object.entries(data.stocks).forEach(([symbol, s]) => {
                availableInstruments.push({ 
                    symbol, 
                    label: (s.name || symbol),
                    category: 'Actions'
                });
            });
            
            // Ajouter le forex
            if (data.forex) {
                Object.entries(data.forex).forEach(([symbol, f]) => {
                    availableInstruments.push({ 
                        symbol, 
                        label: (f.name || symbol),
                        category: 'Forex'
                    });
                });
            }
            
            // Ajouter les cryptomonnaies
            if (data.crypto) {
                Object.entries(data.crypto).forEach(([symbol, c]) => {
                    availableInstruments.push({ 
                        symbol, 
                        label: (c.name || symbol),
                        category: 'Cryptomonnaies'
                    });
                });
            }
            
            // Construire la liste déroulante avec des groupes
            const dd = document.getElementById('tag-dropdown');
            let dropdownHTML = '<option value="">Choisir un instrument…</option>';
            
            // Grouper par catégorie
            const categories = ['Indices', 'Actions', 'Forex', 'Cryptomonnaies'];
            categories.forEach(category => {
                const categoryInstruments = availableInstruments.filter(inst => inst.category === category);
                if (categoryInstruments.length > 0) {
                    dropdownHTML += `<optgroup label="${category}">`;
                    categoryInstruments.forEach(inst => {
                        dropdownHTML += `<option value="${inst.symbol}">${inst.label} (${inst.symbol})</option>`;
                    });
                    dropdownHTML += '</optgroup>';
                }
            });
            
            dd.innerHTML = dropdownHTML;
        } catch (error) {
            console.error('Erreur lors du chargement des données:', error);
            updateApiStatus('error');
        }
    }

    async function plotPerformanceComparisonTags() {
        const start = document.getElementById('tag-start').value;
        const end = document.getElementById('tag-end').value || new Date().toISOString().split('T')[0];
        const syms = tagSelected.map(s => s.symbol);
        if (!syms.length) { alert('Add at least one instrument'); return; }
        
        const qs = start ? `&start=${encodeURIComponent(start)}` : '';
        const qsEnd = end ? `&end=${encodeURIComponent(end)}` : '';
        const responses = await Promise.all(syms.map(s => fetch(`/api/chart-data-v2/${s}?timeframe=1y${qs}${qsEnd}`)));
        const payloads = await Promise.all(responses.map(r => r.json()));
        
        const toISO = (label) => {
            // Si le label est déjà au format YYYY-MM-DD, le retourner tel quel
            if (label && label.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return label;
            }
            // Sinon, traiter le format DD/MM/YYYY
            const parts = (label || '').split('/');
            if (parts.length === 3) {
                const [dd, mm, yyyy] = parts;
                return `${yyyy}-${mm}-${dd}`;
            }
            return label;
        };
        const series = [];
        syms.forEach((sym, i) => {
            const p = payloads[i];
            if (!p || p.error) {
                return;
            }
            const pts = (p.labels || []).map((L, idx) => ({ x: toISO(L), y: Number(p.datasets[0].data[idx]) }));
            series.push({ symbol: sym, points: pts });
        });
        
        if (series.length === 0) { 
            alert('Data not available'); 
            return; 
        }
        const masterLabelsISO = Array.from(new Set(series.flatMap(s => s.points.map(pt => pt.x)))).sort();
        const masterLabelsDisplay = masterLabelsISO.map(iso => {
            if (iso && iso.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const [yyyy, mm, dd] = iso.split('-'); 
                return `${dd}/${mm}/${yyyy}`;
            }
            return iso;
        });
        const palette = [
            'rgb(59,130,246)','rgb(234,88,12)','rgb(34,197,94)','rgb(168,85,247)',
            'rgb(244,63,94)','rgb(20,184,166)','rgb(250,204,21)','rgb(99,102,241)',
            'rgb(217,119,6)','rgb(16,185,129)'
        ];
        // Séparer les devises des autres instruments
        const fxSeries = [];
        const nonFxSeries = [];
        
        series.forEach(s => {
            const instrument = availableInstruments.find(i => i.symbol === s.symbol);
            if (instrument && instrument.category === 'Forex') {
                fxSeries.push(s);
            } else {
                nonFxSeries.push(s);
            }
        });
        
        // Vérifier s'il y a des devises sélectionnées
        const hasForex = fxSeries.length > 0;
        
        const datasets = series.map((s, idx) => {
            const map = new Map(); 
            s.points.forEach(pt => map.set(pt.x, Number(pt.y)));
            
            const instrument = availableInstruments.find(i => i.symbol === s.symbol);
            const isForex = instrument && instrument.category === 'Forex';
            
            let data;
            if (isForex) {
                // Pour les devises, utiliser les valeurs brutes (pas de normalisation base 100)
                data = masterLabelsISO.map(iso => { 
                    const v = map.get(iso); 
                    return isFinite(v) ? v : null; 
                });
            } else {
                // Pour les autres instruments, normaliser en base 100
                let base = null; 
                for (let i = 0; i < masterLabelsISO.length; i++) { 
                    const v = map.get(masterLabelsISO[i]); 
                    if (isFinite(v) && v > 0) { 
                        base = v; 
                        break; 
                    } 
                }
                
                data = masterLabelsISO.map(iso => { 
                    const v = map.get(iso); 
                    if (!isFinite(v) || base === null || base === 0) return null; 
                    return (v / base) * 100.0; 
                });
            }
            
            // Trouver le nom complet correspondant au symbole
            const selectedItem = tagSelected.find(item => item.symbol === s.symbol);
            const displayName = selectedItem ? selectedItem.label : s.symbol;
            
            return { 
                label: displayName, 
                data, 
                borderColor: palette[idx % palette.length], 
                backgroundColor: palette[idx % palette.length].replace('rgb','rgba').replace(')',', 0.08)'), 
                tension: 0.08, 
                borderWidth: 1.0, // Trait plus fin
                pointRadius: 0, // Supprimer les points
                pointHoverRadius: 3, // Point visible seulement au survol
                pointHoverBorderWidth: 2,
                fill: false,
                yAxisID: isForex ? 'y1' : 'y' // Utiliser l'axe Y secondaire pour les devises
            };
        });
        if (perfChart) perfChart.destroy();
        const ctx = document.getElementById('perf-chart').getContext('2d');
        const isLog = document.getElementById('perf-log-scale')?.checked;
        perfChart = new Chart(ctx, {
            type: 'line', data: { labels: masterLabelsDisplay, datasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { display: true, labels: { color: '#ffffff', font: { size: 13 } } } },
                scales: {
                    y: {
                        type: isLog ? 'logarithmic' : 'linear',
                        position: 'left',
                        title: { display: true, text: 'Base 100', color: '#ffffff', font: { size: 13 } },
                        ticks: { color: '#ffffff', font: { size: 12 }, callback: (v)=>{ try { return Number(v).toLocaleString('fr-FR'); } catch { return v; } } },
                        grid: { color: 'rgba(255,255,255,0.12)', lineWidth: 0.6 }
                    },
                    ...(hasForex && {
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Taux de change', color: '#ffffff', font: { size: 13 } },
                            ticks: { color: '#ffffff', font: { size: 12 }, callback: (v)=>{ try { return Number(v).toLocaleString('fr-FR', { minimumFractionDigits: 4, maximumFractionDigits: 4 }); } catch { return v; } } },
                            grid: { drawOnChartArea: false, color: 'rgba(255,255,255,0.12)', lineWidth: 0.6 }
                        }
                    }),
                    x: {
                        grid: { color: 'rgba(255,255,255,0.10)', lineWidth: 0.6 },
                        ticks: {
                            autoSkip: true,
                            minRotation: 30,
                            maxRotation: 45,
                            color: '#ffffff',
                            font: { size: 12 },
                            callback: function(value) {
                                try {
                                    const label = this.getLabelForValue(value);
                                    const parts = (label || '').split('/');
                                    if (parts.length === 3) {
                                        const [dd, mm, yyyy] = parts;
                                        const d = new Date(`${yyyy}-${mm}-${dd}T00:00:00Z`);
                                        return d.toLocaleDateString('fr-FR', { month: 'short', year: 'numeric' });
                                    }
                                    return label;
                                } catch { return value; }
                            }
                        }
                    }
                }
            }
        });
        
        // Mettre à jour le tableau des métriques de risque (exclure les devises)
        const seriesForTable = series.filter(s => {
            const instrument = availableInstruments.find(i => i.symbol === s.symbol);
            return !(instrument && instrument.category === 'Forex');
        });
        updateRiskMetricsTable(seriesForTable);
    }

    function updateRiskMetricsTable(series) {
        if (!series || series.length === 0) return;
        
        const bodyContainer = document.getElementById('risk-table-body');
        
        // Générer les en-têtes des colonnes
        const headerRow = document.querySelector('thead tr');
        // Supprimer tous les en-têtes existants sauf le premier (Métrique)
        while (headerRow.children.length > 1) {
            headerRow.removeChild(headerRow.lastChild);
        }
        
        series.forEach(s => {
            const th = document.createElement('th');
            th.className = 'px-4 py-3 text-center text-foreground font-medium border-b ';
            // Utiliser le label (nom) au lieu du symbole
            const instrument = availableInstruments.find(i => i.symbol === s.symbol);
            const displayName = instrument ? instrument.label : s.symbol;
            
            // Tronquer les noms trop longs pour éviter les problèmes d'affichage
            let shortName = displayName;
            if (displayName.length > 15) {
                // Essayer de tronquer intelligemment
                if (displayName.includes(' ')) {
                    const words = displayName.split(' ');
                    if (words.length >= 2) {
                        shortName = words[0] + ' ' + words[1];
                        if (shortName.length > 15) {
                            shortName = words[0].substring(0, 12) + '...';
                        }
                    } else {
                        shortName = displayName.substring(0, 12) + '...';
                    }
                } else {
                    shortName = displayName.substring(0, 12) + '...';
                }
            }
            
            th.textContent = shortName;
            th.title = displayName; // Tooltip avec le nom complet
            headerRow.appendChild(th);
        });
        
        // Récupérer les métriques depuis le backend Python
        const start = document.getElementById('tag-start').value;
        const end = document.getElementById('tag-end').value || new Date().toISOString().split('T')[0];
        
        Promise.all(series.map(s => {
            const url = `/api/risk-metrics/${s.symbol}?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`;
            return fetch(url).then(r => r.json());
        })).then(metricsData => {
            
            // Optimiser la largeur du tableau selon le nombre de colonnes
            const table = document.querySelector('.risk-metrics-table table');
            if (series.length <= 2) {
                table.classList.add('few-columns');
            } else {
                table.classList.remove('few-columns');
            }
            
            // Générer le contenu du tableau
            bodyContainer.innerHTML = '';
            
            const metricRows = [
                { key: 'annualized_return', label: 'Annualized Return (%)', shortLabel: 'Annual Return (%)', format: (v) => {
                    const formatted = v.toFixed(2) + '%';
                    return formatted.length > 10 ? v.toFixed(1) + '%' : formatted;
                }},
                { key: 'volatility', label: 'Annual Volatility (%)', shortLabel: 'Volatility (%)', format: (v) => {
                    const formatted = v.toFixed(2) + '%';
                    return formatted.length > 10 ? v.toFixed(1) + '%' : formatted;
                }},
                { key: 'sharpe_ratio', label: 'Sharpe Ratio', shortLabel: 'Sharpe', format: (v) => v.toFixed(3) },
                { key: 'max_drawdown', label: 'Max Drawdown (%)', shortLabel: 'Max DD (%)', format: (v) => {
                    const formatted = v.toFixed(2) + '%';
                    return formatted.length > 10 ? v.toFixed(1) + '%' : formatted;
                }},
                { key: 'var_95', label: 'VaR 95% (%)', shortLabel: 'VaR 95%', format: (v) => {
                    const formatted = v.toFixed(2) + '%';
                    return formatted.length > 10 ? v.toFixed(1) + '%' : formatted;
                }},
                { key: 'total_return', label: 'Total Return (%)', shortLabel: 'Total Return (%)', format: (v) => {
                    // Pour les rendements très élevés, utiliser une notation compacte
                    if (v > 1000) {
                        return (v/1000).toFixed(1) + 'k%';
                    } else if (v > 100) {
                        return v.toFixed(0) + '%';
                    } else {
                        const formatted = v.toFixed(2) + '%';
                        return formatted.length > 10 ? v.toFixed(1) + '%' : formatted;
                    }
                }}
            ];
            
            metricRows.forEach(metric => {
                const row = document.createElement('tr');
                
                // Metric cell
                const metricCell = document.createElement('td');
                metricCell.className = 'px-4 py-3 text-foreground font-medium border-b ';
                
                // Use short label on mobile, full label on desktop
                const isMobile = window.innerWidth <= 768;
                const displayLabel = isMobile ? metric.shortLabel : metric.label;
                metricCell.textContent = displayLabel;
                metricCell.title = metric.label; // Tooltip with full name
                
                row.appendChild(metricCell);
                
                // Value cells
                series.forEach(s => {
                    const metricData = metricsData.find(m => m.symbol === s.symbol);
                    const cell = document.createElement('td');
                    cell.className = 'px-4 py-3 text-center  border-b ';
                    
                                         if (metricData && !metricData.error) {
                         const value = metricData[metric.key];
                         cell.textContent = metric.format(value);
                         
                         // Improved color coding: Green (good) / Orange (medium) / Red (bad)
                         if (metric.key === 'volatility') {
                             // Volatility: Lower is better
                             if (value < 0.15) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value < 0.25) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         } else if (metric.key === 'var_95') {
                             // VaR: Closer to 0 is better
                             if (value > -0.02) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value > -0.05) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         } else if (metric.key === 'max_drawdown') {
                             // Max Drawdown: Lower is better
                             if (value < 0.15) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value < 0.30) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         } else if (metric.key === 'sharpe_ratio') {
                             // Sharpe Ratio: Higher is better
                             if (value > 1.0) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value > 0.5) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         } else if (metric.key === 'total_return') {
                             // Total Return: Higher is better
                             if (value > 0.20) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value > 0.05) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else if (value > 0) {
                                 cell.className += ' text-blue-500';
                                 cell.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                                 cell.style.borderLeft = '3px solid #3b82f6';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         } else if (metric.key === 'annualized_return') {
                             // Annual Return: Higher is better
                             if (value > 0.12) {
                                 cell.className += ' text-green-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(16, 185, 129, 0.1)';
                                 cell.style.borderLeft = '3px solid #10b981';
                             } else if (value > 0.06) {
                                 cell.className += ' text-orange-500';
                                 cell.style.backgroundColor = 'rgba(249, 115, 22, 0.1)';
                                 cell.style.borderLeft = '3px solid #f97316';
                             } else if (value > 0.02) {
                                 cell.className += ' text-blue-500';
                                 cell.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                                 cell.style.borderLeft = '3px solid #3b82f6';
                             } else if (value > 0) {
                                 cell.className += ' text-gray-400';
                                 cell.style.backgroundColor = 'rgba(156, 163, 175, 0.1)';
                                 cell.style.borderLeft = '3px solid #9ca3af';
                             } else {
                                 cell.className += ' text-red-500 font-semibold';
                                 cell.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                                 cell.style.borderLeft = '3px solid #ef4444';
                             }
                         }
                    } else {
                        cell.textContent = 'N/A';
                    }
                    
                    row.appendChild(cell);
                });
                
                bodyContainer.appendChild(row);
            });
        }).catch(error => {
            bodyContainer.innerHTML = '<tr><td colspan="' + (series.length + 1) + '" class="px-4 py-3 text-center ">Error calculating metrics</td></tr>';
        });
    }

    document.getElementById('tag-search').addEventListener('input', (e) => renderTagSuggestions(e.target.value));
    document.getElementById('tag-dropdown').addEventListener('change', (e) => {
        const sym = e.target.value; if (!sym) return;
        const item = availableInstruments.find(x => x.symbol === sym);
        if (item && !tagSelected.find(s => s.symbol === sym)) { tagSelected.push(item); renderTagSelected(); }
        e.target.value = '';
    });
    document.getElementById('tag-plot').addEventListener('click', (e) => { e.preventDefault(); plotPerformanceComparisonTags(); });
    document.getElementById('perf-log-scale')?.addEventListener('change', () => plotPerformanceComparisonTags());

    loadMarketData().then(async () => {
        renderTagSelected();
        const startEl = document.getElementById('tag-start');
        if (startEl && !startEl.value) startEl.value = '2015-01-01';
        const endEl = document.getElementById('tag-end');
        if (endEl && !endEl.value) endEl.value = new Date().toISOString().split('T')[0];
        try { await plotPerformanceComparisonTags(); } catch (e) { /* ignore */ }
    });
    
    // Periodic API status check (every 30 seconds)
    setInterval(() => {
        fetch('/api/market-data')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    updateApiStatus('error');
                } else {
                    updateApiStatus('connected');
                }
            })
            .catch(() => {
                updateApiStatus('error');
            });
    }, 30000);
    
    // Update table labels when window size changes
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            // Recalculate table if it already exists
            if (perfChart && tagSelected.length > 0) {
                plotPerformanceComparisonTags();
            }
        }, 300);
    });
</script>
{% endblock %}

